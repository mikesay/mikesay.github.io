<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在Kubernetes中创建自托管GitHub Actions Runner</title>
    <link href="/2022/04/10/creating-self-hosted-actions-runner-k8s/"/>
    <url>/2022/04/10/creating-self-hosted-actions-runner-k8s/</url>
    
    <content type="html"><![CDATA[<p>GitHub Actions 是一个持续集成和交付 (CI&#x2F;CD) 平台，利用工作流（Workflow）可以创建自动化构建、测试和部署管道。GitHub Actions不仅限于构建CI&#x2F;CD工作流，它可以定义任意的工作流完成某个自动化的功能， 例如，定义一个工作流，当代码仓库中有新的问题创建时自动添加适当的标签。GitHub Action Runner是执行工作流的组件。本文介绍了利用开源项目<a href="https://github.com/actions/actions-runner-controller">Actions Runner Controller</a>在Kubernetes中部署和管理自托管的容器版本的GitHub Action Runner。</p><span id="more"></span><h1 id="GitHub-Action"><a href="#GitHub-Action" class="headerlink" title="GitHub Action"></a>GitHub Action</h1><p>下图是GitHub Actions概念或组件：<br><img src="/2022/04/10/creating-self-hosted-actions-runner-k8s/1.png"></p><ul><li>Workflow（工作流）是一个可配置的自动化过程，它由一个或多个Job（作业）组成。  </li><li>Event（事件）是代码仓库中触发工作流的特定活动。  </li><li>Job（作业）是一组步骤的组合，运行在同一个GitHub Action Runner上。  </li><li>Action（动作）由Job中的步骤调用。GitHub Actions提供了很多开箱即用的Actions，用户也可以封装一些通用的actions供组织使用。  </li><li>GitHub Action Runner是在工作流被触发时执行工作流的组件。一个GitHub Action Runner一次可以执行一个作业，当Job结束后，Runner会重启恢复到干净的状态。GitHub提供了一些缺省的Runners供公共仓库免费使用，而私有仓库则需要付费使用（GitHub为付费用户提供了一定的免费使用额度，详细可以参考<a href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#about-spending-limits">GitHub Actions的计费</a>）。替代方案就是自己部署GitHub Action Runner。</li></ul><h1 id="Actions-Runner-Controller"><a href="#Actions-Runner-Controller" class="headerlink" title="Actions Runner Controller"></a>Actions Runner Controller</h1><p>GitHub的官网只提供了在虚拟机中<a href="https://docs.github.com/en/enterprise-cloud@latest/actions/hosting-your-own-runners/adding-self-hosted-runners">部署自托管的GitHub Action Runner</a>的文档，但是随着云原生技术和Kubernetes的发展，越来越多的CI&#x2F;CD系统逐渐容器化并运行在Kubernetes平台中，从而使系统本身变得更具弹性和韧性，比如Jenkins的agent。GitHub Action Runner也支持通过容器运行在Kubernetes平台中，Actions Runner Controller是一个自定义的Kubernetes Operator，通过声明式的方式来定义、创建、配置和管理运行在Kubernetes中的GitHub Action Runner，具体架构如下图：<br><img src="/2022/04/10/creating-self-hosted-actions-runner-k8s/5.png"></p><h1 id="安装Actions-Runner-Controller"><a href="#安装Actions-Runner-Controller" class="headerlink" title="安装Actions Runner Controller"></a>安装Actions Runner Controller</h1><p>推荐使用Helm的方式安装Actions Runner Controller，因为Actions Runner Controller的Helm Chart提供了丰富的模板参数用来定制安装。</p><h2 id="设置GitHub-API认证"><a href="#设置GitHub-API认证" class="headerlink" title="设置GitHub API认证"></a>设置GitHub API认证</h2><p>本文选择PAT（Personal Access Token，个人访问令牌）的方式认证GitHub API。</p><blockquote><p>另一种认证方式为GitHub App，两种认证方式的区别以及配置GitHub App认证可以参考<a href="https://github.com/actions/actions-runner-controller/blob/master/docs/authenticating-to-the-github-api.md">Authenticating to the GitHub API</a>。</p></blockquote><p>点击<a href="https://github.com/settings/tokens/new">创建PAT</a>，并参考以下不同级别的Runner所需要的权限创建PAT：</p><p><strong>代码仓库级别的Runner需要的权限</strong></p><ul><li>repo (Full control)</li></ul><p><strong>组织(org)级别的Runner需要的权限</strong></p><ul><li>repo (Full control)</li><li>admin:org (Full control)</li><li>admin:public_key (read:public_key)</li><li>admin:repo_hook (read:repo_hook)</li><li>admin:org_hook (Full control)</li><li>notifications (Full control)</li><li>workflow (Full control)</li></ul><p><strong>企业级别的Runners需要的权限</strong></p><ul><li>admin:enterprise (manage_runners:enterprise)</li></ul><blockquote><p>当您部署企业Runner时，它们将获得对GitHub组织（Org）的访问权限，但是，默认情况下<strong>不允许</strong>访问代码仓库本身。 每个GitHub组织（Org）都必须允许在代码仓库中使用企业&gt; Runner Group作为初始的一次性配置步骤，这只需要完成一次，之后对于该Runner Group来说是永久性的。<br><img src="/2022/04/10/creating-self-hosted-actions-runner-k8s/3.jpg"><br>组织和企业级别的Runner需要创建在Runner Group里，通过Runner Group对这些Runners分类和统一赋权，即哪些代码仓库和工作流可以使用这个Group里的Runners。<br><img src="/2022/04/10/creating-self-hosted-actions-runner-k8s/4.jpg"></p></blockquote><h2 id="安装cert-manager"><a href="#安装cert-manager" class="headerlink" title="安装cert-manager"></a>安装cert-manager</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add jetstack https://charts.jetstack.io<br>helm repo update<br>helm upgrade -i cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version <span class="hljs-variable">$&#123;CERT_MANAGER_VERSION&#125;</span> --<span class="hljs-built_in">set</span> installCRDs=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Actions Runner Controller中的admission webhook需要使用cert-manager创建一个自签名的ssl证书。</p>          </div><h2 id="Helm方式安装Actions-Runner-Controller"><a href="#Helm方式安装Actions-Runner-Controller" class="headerlink" title="Helm方式安装Actions Runner Controller"></a>Helm方式安装Actions Runner Controller</h2><ul><li><p>创建命名空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create ns acr-system<br></code></pre></td></tr></table></figure></li><li><p>用前面生成的PAT创建一个名为“controller-manager”的secret资源  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create secret generic controller-manager \<br>    -n actions-runner-system \<br>    --from-literal=github_token=<span class="hljs-variable">$&#123;GITHUB_TOKEN&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>添加helm chart仓库并更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add actions-runner-controller  https://github.com/actions-runner-controller/actions-runner-controller<br>helm repo update<br></code></pre></td></tr></table></figure></li><li><p>安装Actions Runner Controller  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm upgrade -i actions-runner-controller actions-runner-controller/actions-runner-controller \<br>  --version <span class="hljs-variable">$&#123;ACTION_RUNNER_CONTROLLER_VERSION&#125;</span> \<br>  -n actions-runner-system<br></code></pre></td></tr></table></figure><blockquote><ul><li>可以执行命令 <code>helm search repo actions-runner-controller</code> 查询最新的helm chart版本：<br><img src="/2022/04/10/creating-self-hosted-actions-runner-k8s/2.png">  </li><li>actions runner controller缺省会监听所有命名空间中的Runner CRD资源。可以通过添加选项<code>--set=scope.singleNamespace=true</code>只关注actions runner controller所在的命名空间的runner资源。</li></ul></blockquote></li></ul><h2 id="降低Docker-Hub限流的影响"><a href="#降低Docker-Hub限流的影响" class="headerlink" title="降低Docker Hub限流的影响"></a>降低Docker Hub限流的影响</h2><p>从2020年11月20日开始，Docker Hub对匿名和免费认证的使用开始了限流措施。匿名和免费Docker Hub 用户每六小时只能发出 100 和 200 个容器映像拉取请求。 您可以在<a href="5">这里</a>获取更多详细信息。如果部署频率不是很高，比如个人测试用，直接用上面的命令部署应该不会有问题，但是如果部署频率比较高，或者在公司内网的环境中部署，而公司的公网出口IP往往是固定的，则很有可能会触发限流导致部署失败。其中一个解决办法就是使用免费账号来拉取镜像，这样可以享受每6个小时200个容器镜像拉取请求。具体的操作步骤为：</p><ol><li>参考<a href="6">创建Docker Hub账号</a>注册一个Docker Hub免费账号</li><li>参考<a href="https://docs.docker.com/docker-hub/access-tokens/">创建账号对应的PAT(个人访问凭证)</a>生成一个个人访问凭证（官方推荐用个人访问凭证的方式认证Docker Hub）</li><li>如果是使用docker命令行拉取镜像，先执行下面的命令登陆Docker Hub，并且在提示密码时输入个人访问凭证  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker login --username <span class="hljs-variable">$&#123;DOCKER_HUB_USERNAME&#125;</span><br></code></pre></td></tr></table></figure></li><li>如果是Kubernetes中的部署要拉取镜像，先执行下面的命令在对应的命名空间里创建docker pull secret，并且在Pod的部署yaml文件中显式添加这个secret  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create secret docker-registry image-pull-secret \<br>    --docker-server=docker.io\<br>    --docker-username=<span class="hljs-variable">$&#123;DOCKER_HUB_USERNAME&#125;</span> \<br>    --docker-password=<span class="hljs-variable">$&#123;DOCKER_HUB_USER_PAT&#125;</span> \<br>    -n <span class="hljs-variable">$&#123;NAMESPACE&#125;</span><br></code></pre></td></tr></table></figure></li></ol><p>另一个解决办法就是部署一个带有proxy功能的私有镜像仓库，比如<a href="8">Harbor</a>，<a href="9">Nexus</a>，或者<a href="10">Artifactory</a>或者，配置一个Docker Hub的代理（可以通过免费用户来认证），每次部署时通过代理来拉取docker镜像并缓存，这样可以降低因拉取重复镜像而消耗限流额度。随着时间的推移，常用的docker镜像基本上都能缓存到私有仓库里。</p><p>以上两种方式都需要我们在部署actions runner controller时配置docker pull secret用来拉取镜像，且第二种方法还需要更改镜像地址。对于Helm chart的部署方式，基本上只需要定制它的values.yaml文件即可。具体步骤如下：</p><ol><li><p>执行下面命令获取Helm chart缺省的values.yaml文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm show values actions-runner-controller/actions-runner-controller --version <span class="hljs-variable">$&#123;ACTION_RUNNER_CONTROLLER_VERSION&#125;</span> &gt; values.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改缺省的values.yaml文件添加docker pull secret或者更改docker镜像地址</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">&quot;$&#123;DOCKER_HUB_PROXY_SERVER&#125;/summerwind/actions-runner-controller&quot;</span><br>  <span class="hljs-attr">actionsRunnerRepositoryAndTag:</span> <span class="hljs-string">&quot;$&#123;$&#123;DOCKER_HUB_PROXY_SERVER&#125;/summerwind/actions-runner:latest&quot;</span><br>  <span class="hljs-attr">dindSidecarRepositoryAndTag:</span> <span class="hljs-string">&quot;$&#123;$&#123;DOCKER_HUB_PROXY_SERVER&#125;&#125;/docker:dind&quot;</span><br>  <span class="hljs-attr">pullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>  <span class="hljs-comment"># The default image-pull secrets name for self-hosted runner container.</span><br>  <span class="hljs-comment"># It&#x27;s added to spec.ImagePullSecrets of self-hosted runner pods.</span><br>  <span class="hljs-attr">actionsRunnerImagePullSecrets:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;DOCKER_PULL_SECRET&#125;</span><br><br><span class="hljs-attr">imagePullSecrets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">$&#123;DOCKER_PULL_SECRET&#125;</span><br></code></pre></td></tr></table></figure>  <div class="note note-info">            <ul><li>.image.repository是actions-runner-controller的镜像地址  </li><li>.image.actionsRunnerRepositoryAndTag是连接GitHub的Action Runner镜像地址  </li><li>.image.dindSidecarRepositoryAndTag是docker server的镜像地址（Action Runner是使用的dind的方式构建应用镜像的，所以一个Action Runner Pod会包含两个容器，一个是runner服务本身，另一个是docker服务，runner通过环境变量DOCKER_HOST引用docker服务。） </li><li>image.actionsRunnerImagePullSecrets是拉取Action Runnder镜像所需要的secret  </li><li>.image.imagePullSecrets是拉取actions-runner-controller的镜像地址</li></ul>          </div></li><li><p>用定制的values.yaml文件安装actions-runner-controller</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm upgrade -i actions-runner-controller actions-runner-controller/actions-runner-controller \<br>  --version <span class="hljs-variable">$&#123;ACTION_RUNNER_CONTROLLER_VERSION&#125;</span> \<br>  -f values.yaml \<br>  -n actions-runner-system<br></code></pre></td></tr></table></figure></li></ol><h1 id="创建GitHub-Action-Runners"><a href="#创建GitHub-Action-Runners" class="headerlink" title="创建GitHub Action Runners"></a>创建GitHub Action Runners</h1><p>GitHub自托管Runners可以部署在管理层次结构的各个级别  </p><ul><li>代码仓库级别</li><li>组织级别</li><li>企业级别</li></ul><p>Action Runner Controller提供了两种CRD资源定义Runners：</p><ul><li>RunnerDeployment (类似于Kubernetes的Deployment资源，无状态)  </li><li>RunnerSet (类似于Kubernetes的StatefulSets资源，有状态)</li></ul><h2 id="创建repository级别的Runner"><a href="#创建repository级别的Runner" class="headerlink" title="创建repository级别的Runner"></a>创建repository级别的Runner</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF | kubectl apply -n actions-runner-system -f -</span><br><span class="hljs-string">apiVersion: actions.summerwind.dev/v1alpha1</span><br><span class="hljs-string">kind: RunnerDeployment</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: mikesay-runner</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  replicas: 2</span><br><span class="hljs-string">  template:</span><br><span class="hljs-string">    spec:</span><br><span class="hljs-string">      volumeMounts:</span><br><span class="hljs-string">      - name: docker-config</span><br><span class="hljs-string">        mountPath: /home/runner/.docker</span><br><span class="hljs-string">      volumes:</span><br><span class="hljs-string">      - name: docker-config</span><br><span class="hljs-string">        secret:</span><br><span class="hljs-string">          secretName: $&#123;DOCKER_PULL_SECRET&#125;</span><br><span class="hljs-string">          items:</span><br><span class="hljs-string">          - key: .dockerconfigjson</span><br><span class="hljs-string">            path: config.json</span><br><span class="hljs-string">      repository: mikesay/mikesay-spikes</span><br><span class="hljs-string">      labels:</span><br><span class="hljs-string">        - mikesay</span><br><span class="hljs-string">        - mikesay-spikes</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>通过volumes和volumeMounts可以将docker镜像拉取的secret配置进Runner容器，这样Runner在执行Job时也可以从私有镜像仓库拉取和上传镜像了。如果不需要，也可以不添加。</p>          </div><h2 id="创建orgnization级别的Runner"><a href="#创建orgnization级别的Runner" class="headerlink" title="创建orgnization级别的Runner"></a>创建orgnization级别的Runner</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF | kubectl apply -n actions-runner-system -f -</span><br><span class="hljs-string">apiVersion: actions.summerwind.dev/v1alpha1</span><br><span class="hljs-string">kind: RunnerDeployment</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: mikesay-runner</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  replicas: 1</span><br><span class="hljs-string">  template:</span><br><span class="hljs-string">    spec:</span><br><span class="hljs-string">      volumeMounts:</span><br><span class="hljs-string">      - name: docker-config</span><br><span class="hljs-string">        mountPath: /home/runner/.docker</span><br><span class="hljs-string">      volumes:</span><br><span class="hljs-string">      - name: docker-config</span><br><span class="hljs-string">        secret:</span><br><span class="hljs-string">          secretName: $&#123;DOCKER_PULL_SECRET&#125;</span><br><span class="hljs-string">          items:</span><br><span class="hljs-string">          - key: .dockerconfigjson</span><br><span class="hljs-string">            path: config.json</span><br><span class="hljs-string">      organization: mikesay</span><br><span class="hljs-string">      group: default</span><br><span class="hljs-string">      labels:</span><br><span class="hljs-string">        - mikesay</span><br><span class="hljs-string">      env: []</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Runner Group用来限制对应GitHub组织里的哪些代码仓库和工作流能够使用GitHub Runners。只有升级到GitHub企业版，才能创建自定义的group，否则只能用缺省的default组。</p>          </div><h2 id="使用RunnerSet创建repository级别的Runner"><a href="#使用RunnerSet创建repository级别的Runner" class="headerlink" title="使用RunnerSet创建repository级别的Runner"></a>使用RunnerSet创建repository级别的Runner</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF | kubectl apply -n actions-runner-system -f -</span><br><span class="hljs-string">apiVersion: actions.summerwind.dev/v1alpha1</span><br><span class="hljs-string">kind: RunnerSet</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: mikesay-mikesay-spikes-runnerset</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  ephemeral: false</span><br><span class="hljs-string">  persistentVolumeClaimRetentionPolicy:</span><br><span class="hljs-string">    whenDeleted: Retain</span><br><span class="hljs-string">    whenScaled: Retain</span><br><span class="hljs-string">  replicas: 2</span><br><span class="hljs-string">  repository: mikesay/mikesay-spikes</span><br><span class="hljs-string">  labels:</span><br><span class="hljs-string">    - mikesay</span><br><span class="hljs-string">    - mikesay-spikes</span><br><span class="hljs-string">  selector:</span><br><span class="hljs-string">    matchLabels:</span><br><span class="hljs-string">      app: mikesay</span><br><span class="hljs-string">  serviceName: mikesay</span><br><span class="hljs-string">  template:</span><br><span class="hljs-string">    metadata:</span><br><span class="hljs-string">      labels:</span><br><span class="hljs-string">        app: mikesay</span><br><span class="hljs-string">      name: mikerunner</span><br><span class="hljs-string">    spec:</span><br><span class="hljs-string">      volumeMounts:</span><br><span class="hljs-string">      - name: www</span><br><span class="hljs-string">        mountPath: /runner/data</span><br><span class="hljs-string">      - name: docker-config</span><br><span class="hljs-string">        mountPath: /home/runner/.docker</span><br><span class="hljs-string">      volumes:</span><br><span class="hljs-string">      - name: docker-config</span><br><span class="hljs-string">        secret:</span><br><span class="hljs-string">          secretName: $&#123;DOCKER_PULL_SECRET&#125;</span><br><span class="hljs-string">          items:</span><br><span class="hljs-string">          - key: .dockerconfigjson</span><br><span class="hljs-string">            path: config.json</span><br><span class="hljs-string">  volumeClaimTemplates:</span><br><span class="hljs-string">  - metadata:</span><br><span class="hljs-string">      name: www</span><br><span class="hljs-string">    spec:</span><br><span class="hljs-string">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class="hljs-string">      storageClassName: &quot;standard&quot;</span><br><span class="hljs-string">      resources:</span><br><span class="hljs-string">        requests:</span><br><span class="hljs-string">          storage: 200M</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>K8s</tag>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Podman介绍和使用</title>
    <link href="/2021/10/10/podman-introduction-and-usage/"/>
    <url>/2021/10/10/podman-introduction-and-usage/</url>
    
    <content type="html"><![CDATA[<p>最近Docker公司改变了Docker桌面版（Docker for Mac和Docker for Windows）的商业策略：最晚到2022&#x2F;1&#x2F;31号，需要购买付费订阅了，但对于员工人数小于250，且年收入少于1000万美元的公司仍然免费。虽说对于个人使用Docker桌面版没有影响，但在公司里还是要谨慎使用。 作为对Docker桌面版的替换，本文将对Podman及其使用做一简单的介绍。</p><span id="more"></span><h1 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h1><p><a href="https://podman.io/">Podman</a>是一个无守护进程的开源Linux 原生工具，旨在使用开放容器协议 (OCI) 容器和容器镜像轻松查找、运行、构建、共享和部署应用程序。对于无守护进程这一说法，主要是针对运行在Linux系统中的Podman，因为Podman原生是支持Linux系统的，而在Mac和Windows系统中，仍然需要启动一个Linux虚拟机来管理和运行容器。Podman的架构如下：<br><img src="/2021/10/10/podman-introduction-and-usage/1.jpg"></p><p>Podman是从CRI-O独立出来的一个项目，目的是让CRI-O和Podman能够独立发展。Podman主要包含一个兼容Docker命令的CLI模块和libpod，libpod通过runc创建和执行容器进程。由于Podman底层使用的runc运行时，所以Podman能够使用任何符合OCI标准的镜像包括Docker镜像。</p><h1 id="在Mac上安装Podman"><a href="#在Mac上安装Podman" class="headerlink" title="在Mac上安装Podman"></a>在Mac上安装Podman</h1><p>通过brew命令来安装Podman：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install podman<br></code></pre></td></tr></table></figure><p>通过以下命令在Mac主机上启动一个Podman管理的虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman machine init<br>podman machine start<br></code></pre></td></tr></table></figure><p>可以通过一下命令列出Podman管理的虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman machine list<br></code></pre></td></tr></table></figure><p><img src="/2021/10/10/podman-introduction-and-usage/2.jpg"></p><h1 id="拉取和执行Docker镜像"><a href="#拉取和执行Docker镜像" class="headerlink" title="拉取和执行Docker镜像"></a>拉取和执行Docker镜像</h1><p>通过以下命令拉取Docker镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman pull nginx<br></code></pre></td></tr></table></figure><p>通过以下命令检查所有Podman管理的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman images<br></code></pre></td></tr></table></figure><p><img src="/2021/10/10/podman-introduction-and-usage/3.jpg"></p><p>通过以下命令启动镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman run --name nginx -d -p 8000:80 nginx:latest<br></code></pre></td></tr></table></figure><p>通过以下命令列出运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman ps<br></code></pre></td></tr></table></figure><p><img src="/2021/10/10/podman-introduction-and-usage/4.jpg"></p><p>停止，删除运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman stop nginx<br>podman <span class="hljs-built_in">rm</span> nginx<br></code></pre></td></tr></table></figure><h1 id="设置docker别名"><a href="#设置docker别名" class="headerlink" title="设置docker别名"></a>设置docker别名</h1><p>由于podman与Docker CLI命令具有一对多映射，因此建议按如下所示设置docker别名。这样也可以确保继续使用之前的Docker命令经验。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> docker=podman<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Container</tag>
      
      <tag>Podman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kind创建本地Kubernetes集群</title>
    <link href="/2021/10/10/create-kubernetes-kind/"/>
    <url>/2021/10/10/create-kubernetes-kind/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.mikesay.com/2021/10/06/create-kubernetes-minikube/">Minikube创建本地Kubernetes集群</a>一文中提到过用Docker驱动创建的Kubernetes集群既不支持ingress，也不支持LoadBalancer类型的服务，所以基本上不可用，而通过Hypervisor驱动创建的Kubernetes集群也需要一些额外的配置(端口转发)才能在VPN的情况下使用。Kind是另一款在Docker容器中创建并运行本地Kubernetes集群的工具，比Minikube的Docker驱动更全面，同时也无需额外的配置就可以在VPN的情况下使用。本文将简单介绍下Kind，并在Mac主机上用Kind创建一个本地Kubernetes集群。</p><span id="more"></span><h1 id="Kind介绍"><a href="#Kind介绍" class="headerlink" title="Kind介绍"></a>Kind介绍</h1><p>Kind(Kubernetes In Docker)是一个使用Docker容器“节点”运行本地Kubernetes集群的工具。kind 主要是为测试Kubernetes本身而设计的，但也可以用于本地开发或CI。</p><h2 id="集群组件配置能力"><a href="#集群组件配置能力" class="headerlink" title="集群组件配置能力"></a>集群组件配置能力</h2><p>Kind提供了丰富的配置选项，有集群级别的，也有节点级别的。Kind缺省也是使用kubeadm创建和配置Kubernetes集群，通过Kubeadm Config Patches机制提供了针对Kubeadm的各种配置。详细可参考Kind<a href="https://kind.sigs.k8s.io/docs/user/configuration/">配置</a>这一节。</p><h1 id="Kind架构"><a href="#Kind架构" class="headerlink" title="Kind架构"></a>Kind架构</h1><p><img src="/2021/10/10/create-kubernetes-kind/1.png"></p><p>图中的节点就是一个Docker容器，所有Kubernetes集群的组件(Kube API Server，Kube Scheduler，Kube Controller Manager，Kube Proxy，CoreDNS，ETCD)以及用户Pod都以容器的方式运行在这个节点容器中。</p><h1 id="创建Kubernetes集群"><a href="#创建Kubernetes集群" class="headerlink" title="创建Kubernetes集群"></a>创建Kubernetes集群</h1><p>通过以下命令和配置文件创建一个包含一个主节点和三个工作节点的Kubernetes集群。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind create cluster --config mykind1.yaml<br></code></pre></td></tr></table></figure><p>mykind1.yaml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">mykind1</span><br><span class="hljs-attr">networking:</span><br>  <span class="hljs-comment"># the default CNI will not be installed</span><br>  <span class="hljs-attr">disableDefaultCNI:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># WARNING: It is _strongly_ recommended that you keep this the default</span><br>  <span class="hljs-comment"># (127.0.0.1) for security reasons. However it is possible to change this.</span><br>  <span class="hljs-attr">apiServerAddress:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>  <span class="hljs-comment"># By default the API server listens on a random open port.</span><br>  <span class="hljs-comment"># You may choose a specific port but probably don&#x27;t need to in most cases.</span><br>  <span class="hljs-comment"># Using a random port makes it easier to spin up multiple clusters.</span><br>  <span class="hljs-attr">apiServerPort:</span> <span class="hljs-number">6443</span><br>  <span class="hljs-attr">podSubnet:</span> <span class="hljs-string">&quot;10.244.0.0/16&quot;</span><br>  <span class="hljs-attr">serviceSubnet:</span> <span class="hljs-string">&quot;10.96.0.0/12&quot;</span><br>  <span class="hljs-attr">kubeProxyMode:</span> <span class="hljs-string">&quot;ipvs&quot;</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br>  <span class="hljs-attr">kubeadmConfigPatches:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br><span class="hljs-string">    kind: InitConfiguration</span><br><span class="hljs-string">    nodeRegistration:</span><br><span class="hljs-string">      kubeletExtraArgs:</span><br><span class="hljs-string">        node-labels: &quot;ingress-ready=true&quot;</span><br><span class="hljs-string">    kind: ClusterConfiguration</span><br><span class="hljs-string">    metadata:</span><br><span class="hljs-string">      name: config</span><br><span class="hljs-string">    apiServer:</span><br><span class="hljs-string">      certSANs:</span><br><span class="hljs-string">      - localhost</span><br><span class="hljs-string">      - 127.0.0.1</span><br><span class="hljs-string">      - kubernetes</span><br><span class="hljs-string">      - kubernetes.default.svc</span><br><span class="hljs-string">      - kubernetes.default.svc.cluster.local</span><br><span class="hljs-string">      - kind</span><br><span class="hljs-string">      - 0.0.0.0</span><br><span class="hljs-string"></span>  <span class="hljs-comment"># port forward 80 on the host to 80 on this node</span><br>  <span class="hljs-attr">extraPortMappings:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">hostPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-comment"># optional: set the bind address on the host</span><br>    <span class="hljs-comment"># 0.0.0.0 is the current default</span><br>    <span class="hljs-attr">listenAddress:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>    <span class="hljs-comment"># optional: set the protocol to one of TCP, UDP, SCTP.</span><br>    <span class="hljs-comment"># TCP is the default</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">hostPort:</span> <span class="hljs-number">443</span><br>    <span class="hljs-comment"># optional: set the bind address on the host</span><br>    <span class="hljs-comment"># 0.0.0.0 is the current default</span><br>    <span class="hljs-attr">listenAddress:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>    <span class="hljs-comment"># optional: set the protocol to one of TCP, UDP, SCTP.</span><br>    <span class="hljs-comment"># TCP is the default</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br></code></pre></td></tr></table></figure><p>一些配置参数说明：</p><ul><li><p>禁用默认CNI（”kindnetd”），否则在创建出来的Kubernetes集群无法解析外网域名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">networking:</span><br>  <span class="hljs-comment"># the default CNI will not be installed</span><br>  <span class="hljs-attr">disableDefaultCNI:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>为主节点添加标签”ingress-ready:true”。Kind提供的Nginx Ingress Controller的部署资源中会通过这个标签选择运行在主节点上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kubeadmConfigPatches:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br><span class="hljs-string">  kind: InitConfiguration</span><br><span class="hljs-string">  nodeRegistration:</span><br><span class="hljs-string">    kubeletExtraArgs:</span><br><span class="hljs-string">      node-labels: &quot;ingress-ready=true&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>将容器主节点的80，443端口映射到运行Kind的主机(这里是Mac主机)的80,443端口。Kind提供的Nginx Ingress Controller的服务资源会通过NodePort将服务通过容器主节点的80，443暴露出去，这样用户就可以通过访问本地主机的80，443端口访问运行在集群中的Nginx Ingress Controller。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># port forward 80 on the host to 80 on this node</span><br><span class="hljs-attr">extraPortMappings:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">hostPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-comment"># optional: set the bind address on the host</span><br>  <span class="hljs-comment"># 0.0.0.0 is the current default</span><br>  <span class="hljs-attr">listenAddress:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>  <span class="hljs-comment"># optional: set the protocol to one of TCP, UDP, SCTP.</span><br>  <span class="hljs-comment"># TCP is the default</span><br>  <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>  <span class="hljs-attr">hostPort:</span> <span class="hljs-number">443</span><br>  <span class="hljs-comment"># optional: set the bind address on the host</span><br>  <span class="hljs-comment"># 0.0.0.0 is the current default</span><br>  <span class="hljs-attr">listenAddress:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>  <span class="hljs-comment"># optional: set the protocol to one of TCP, UDP, SCTP.</span><br>  <span class="hljs-comment"># TCP is the default</span><br>  <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><blockquote><p>此处的hostPort指的是运行Kind的主机，也就是Mac主机。</p></blockquote></li></ul><h2 id="配置Kubernetes集群"><a href="#配置Kubernetes集群" class="headerlink" title="配置Kubernetes集群"></a>配置Kubernetes集群</h2><h3 id="安装网络插件Calico"><a href="#安装网络插件Calico" class="headerlink" title="安装网络插件Calico"></a>安装网络插件Calico</h3><ul><li><p>下载Calico安装脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://docs.projectcalico.org/manifests/calico.yaml -O<br></code></pre></td></tr></table></figure></li><li><p>设置环境变量FELIX_IGNORELOOSERPF的值为true，禁用Calico检查。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Source: calico/templates/calico-node.yaml</span><br><span class="hljs-comment"># This manifest installs the calico-node container, as well</span><br><span class="hljs-comment"># as the CNI plugins and network config on</span><br><span class="hljs-comment"># each master and worker node in a Kubernetes cluster.</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">calico-node</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">calico-node</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">calico-node</span><br>  <span class="hljs-attr">updateStrategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">calico-node</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-string">...</span><br>      <span class="hljs-attr">initContainers:</span><br>        <span class="hljs-string">....</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-comment"># Runs calico-node container on each Kubernetes node. This</span><br>        <span class="hljs-comment"># container programs network policy and routes on each</span><br>        <span class="hljs-comment"># host.</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">calico-node</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/calico/node:v3.20.1</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-comment"># Disable the Calico RPF check</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">FELIX_IGNORELOOSERPF</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;true&quot;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>详细参考<a href="https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises#install-calico-with-kubernetes-api-datastore-50-nodes-or-less">Calico官方安装文档</a>，以及博客文章<a href="https://alexbrand.dev/post/creating-a-kind-cluster-with-calico-networking/">Creating a Kind Cluster With Calico Networking</a>。</p></blockquote><h3 id="安装Ingress-Controller"><a href="#安装Ingress-Controller" class="headerlink" title="安装Ingress Controller"></a>安装Ingress Controller</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml<br></code></pre></td></tr></table></figure><h3 id="安装METALLB"><a href="#安装METALLB" class="headerlink" title="安装METALLB"></a>安装METALLB</h3><p>MetalLB是裸机Kubernetes集群的负载均衡实现，使用标准路由协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> version=v0.12.1<br>kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/<span class="hljs-variable">$&#123;version&#125;</span>/manifests/namespace.yaml<br>kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey=<span class="hljs-string">&quot;<span class="hljs-subst">$(openssl rand -base64 128)</span>&quot;</span> <br>kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/<span class="hljs-variable">$&#123;version&#125;</span>/manifests/metallb.yaml<br>kubectl apply -f metallb-configmap.yaml<br></code></pre></td></tr></table></figure><p>metallb-configmap.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">metallb-system</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    address-pools:</span><br><span class="hljs-string">    - name: default</span><br><span class="hljs-string">      protocol: layer2</span><br><span class="hljs-string">      addresses:</span><br><span class="hljs-string">      - 172.18.255.150-172.18.255.250</span><br></code></pre></td></tr></table></figure><p>从节点网段中选取一个IP地址范围设置在metallb-configmap.yaml中用来给LoadBalancer类型服务的IP地址。</p><p>可以通过以下下命令获取node网段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network inspect -f <span class="hljs-string">&#x27;&#123;&#123;.IPAM.Config&#125;&#125;&#x27;</span> kind<br><br>[&#123;172.18.0.0/16  172.18.0.1 map[]&#125; &#123;fc00:f853:ccd:e793::/64  fc00:f853:ccd:e793::1 map[]&#125;]<br></code></pre></td></tr></table></figure><h1 id="Kind-vs-Minikube"><a href="#Kind-vs-Minikube" class="headerlink" title="Kind vs Minikube"></a>Kind vs Minikube</h1><ul><li><p>Kind没有提供类似于Minikube的插件机制，方便用户快速地部署Kubernetes。</p></li><li><p>Kind并没有提供暂停一个集群的功能。</p></li><li><p>和Minikube相比，Kind比较轻量，就是使用Docker容器创建并运行Kubernetes集群，但比Minikube的Docker驱动更全面。个人认为如果能够把Kind集成到Minikube中作为Docker驱动的实现，应该能更有助于两个项目的发展，用户也不需要学习两个工具了。</p></li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文旨在简单介绍Kind，它的架构以及使用，希望能够帮助读者对Kind有个框架性的了解，从而决定是否需要深入使用。对于Kind更详细的用法，可以参考<a href="https://kind.sigs.k8s.io/">官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>K8s</tag>
      
      <tag>Kind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minikube创建本地Kubernetes集群</title>
    <link href="/2021/10/06/create-kubernetes-minikube/"/>
    <url>/2021/10/06/create-kubernetes-minikube/</url>
    
    <content type="html"><![CDATA[<p>在学习和使用Kubernetes的过程中，都希望能够快速创建一个本地的Kubernetes集群用作测试之用。之前一直使用docker公司的docker for mac创建的Kubernetes集群，但是经常出现启动不起来的问题，也没有详细的日志来定位问题，另外docker for mac创建的集群不支持改变系统组件的配置，比如修改API Server或Kubelet的参数，开启某些Alpaha版本的特性等。虽然Minikube已经存在很久，而且早于docker for mac，但是由于种种原因没能尝试，后经同事推荐，尝试了一下，确实蛮强大。本文将简单介绍下Minikube，以及在Mac主机上用Minikube创建和配置一个本地集群。</p><span id="more"></span><h1 id="Minikube介绍"><a href="#Minikube介绍" class="headerlink" title="Minikube介绍"></a>Minikube介绍</h1><p>Minikube是一个命令行工具用来在macOS，Linux和Windows平台中快速创建一个用于学习和开发为目的的Kubernetes集群，同时也提供了丰富的集群管理功能。因为Minikub的目标不是用来创建和管理生产用的Kubernetes集群，所以不会支持所有可能的Kubernetes部署配置，例如不同类型的存储，网络等。以下是Minikube的一些指导原则：</p><ul><li>用户友好</li><li>支持所有Kuberenetes特性</li><li>跨平台</li><li>可靠</li><li>最少的第三方软件依赖</li><li>最少的资源消耗</li></ul><h2 id="集群创建能力的抽象"><a href="#集群创建能力的抽象" class="headerlink" title="集群创建能力的抽象"></a>集群创建能力的抽象</h2><p>Minikube缺省使用kubeadm创建和配置Kubernetes集群，但是通过参数(-b, –bootstrapper)将底层创建集群的能力抽像出来，这就为集成其它的Kubernetes集群创建工具提供了可能。</p><h2 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title="丰富的插件"></a>丰富的插件</h2><p>Minikube提供了丰富的开箱即用的插件用来帮助开发人员快速地配置Kubernetes集群，比如ingress插件用来安装ingress controller，dashboard插件用来安装Kubernetes的管理门户。通过命令<code>minikube addons list</code>可以列出支持的所有插件：<br><img src="/2021/10/06/create-kubernetes-minikube/2.jpg"></p><h2 id="丰富的集群组件配置能力"><a href="#丰富的集群组件配置能力" class="headerlink" title="丰富的集群组件配置能力"></a>丰富的集群组件配置能力</h2><p>比起docker for mac创建的Kubernetes集群，Minikube提供了丰富的参数类型用来配置集群组件。可以参考<a href="https://minikube.sigs.k8s.io/docs/commands/start/">https://minikube.sigs.k8s.io/docs/commands/start/</a> 查看<code>minikube start</code>命令中用于配置集群的参数，尤其是<code>--extra-config</code>参数可以用来对不同组件进行设置。参考<a href="https://minikube.sigs.k8s.io/docs/handbook/config/">https://minikube.sigs.k8s.io/docs/handbook/config/</a> 查看详细的集群配置功能。</p><h2 id="丰富的集群管理命令"><a href="#丰富的集群管理命令" class="headerlink" title="丰富的集群管理命令"></a>丰富的集群管理命令</h2><p>Minikube的start，stop和pause，unpause命令提供了不同级别的集群启停功能，从而释放出CPU，内存资源。Minikube stop命令会停掉运行Kubernetes集群的虚拟机，同时也会清理掉所有的容器镜像和持久卷，但仍旧会保留当前集群的所有的配置，而Minikube start命令则会重启虚拟机。Minikube pause命令不会停掉运行Kubernetes集群的虚拟机以及清理掉所有的容器镜像和持久卷，只会停掉Kubernetes集群，但也不会停掉docker的守护进程，而Minikube unpause命令会重新启动Kubernetes集群。</p><h1 id="Minikube的架构"><a href="#Minikube的架构" class="headerlink" title="Minikube的架构"></a>Minikube的架构</h1><p><img src="/2021/10/06/create-kubernetes-minikube/1.jpg"></p><ul><li><p>Minikube驱动层使用docker-machine创建不同类型的运行Kubernetes集群的工作节点。</p></li><li><p>Master和Worker就是Minikube通过驱动层创建出来的Kubernetes集群的工作节点。工作节点可以是运行在主机上的虚拟机、独立的容器，也可以是已经存在的且已经配置好的虚拟机（本地或远程的），或者就是主机本身。</p></li></ul><h2 id="Hypervisor驱动"><a href="#Hypervisor驱动" class="headerlink" title="Hypervisor驱动"></a>Hypervisor驱动</h2><p>Minikube会根据指定的Hypervisor驱动在主机上启动一到多个虚拟机，并将它们配置成即将创建的Kubernetes集群的工作节点。不同类型的主机(Mac, Linux, Windows)支持的虚拟化技术有差异，所以会有不同的Hypervisor驱动。</p><h3 id="Linux主机支持的Hypervisor驱动"><a href="#Linux主机支持的Hypervisor驱动" class="headerlink" title="Linux主机支持的Hypervisor驱动"></a>Linux主机支持的Hypervisor驱动</h3><ul><li>KVM2</li><li>VirtualBox</li></ul><h3 id="Mac主机支持的Hypervisor驱动"><a href="#Mac主机支持的Hypervisor驱动" class="headerlink" title="Mac主机支持的Hypervisor驱动"></a>Mac主机支持的Hypervisor驱动</h3><ul><li>Hyperkit</li><li>VirtualBox</li><li>Parallels</li><li>VMware</li></ul><h3 id="Windows主机支持的Hypervisor驱动"><a href="#Windows主机支持的Hypervisor驱动" class="headerlink" title="Windows主机支持的Hypervisor驱动"></a>Windows主机支持的Hypervisor驱动</h3><ul><li>Hyper-V</li><li>VirtualBox</li><li>VMware</li></ul><h2 id="Docker驱动"><a href="#Docker驱动" class="headerlink" title="Docker驱动"></a>Docker驱动</h2><p>当选择Docker驱动选项时，Minikube会利用docker in docker技术启动一到多个容器，并将它们配置成即将创建的Kubernetes集群的工作节点，即所谓的Kubernetes in docker。</p><h3 id="Linux主机的Docker驱动"><a href="#Linux主机的Docker驱动" class="headerlink" title="Linux主机的Docker驱动"></a>Linux主机的Docker驱动</h3><ul><li>Docker - container-based</li><li>Podman - container（试验阶段）</li></ul><p>Docker是原生支持Linux系统的，所以在Linux主机中Docker的守护进程是直接运行在主机中的，相对来说性能会高点。Podman是另一个取代Docker的容器工具，完全兼容OCI标准。Podman也是原生支持Linux系统，而且在Linux系统中它是没有守护进程的，所谓的daemonless。目前Minikube支持Podman还处于试验阶段。</p><h3 id="Mac主机支持的Docker驱动"><a href="#Mac主机支持的Docker驱动" class="headerlink" title="Mac主机支持的Docker驱动"></a>Mac主机支持的Docker驱动</h3><ul><li>Docker - VM + Container (preferred)</li></ul><p>Docker并没有原生支持Mac，所以Docker会在Mac主机上启动一个Hyperkit的虚拟机，并将它配置为Docker的服务端，而在Mac主机上的客户端则通过Unix Socket与Docker服务通信。</p><h3 id="Windows主机支持的Docker驱动"><a href="#Windows主机支持的Docker驱动" class="headerlink" title="Windows主机支持的Docker驱动"></a>Windows主机支持的Docker驱动</h3><ul><li>Docker - VM + Container (preferred)</li></ul><p>通Mac一样，Docker也没有原生支持WIndows，所以需要在Windows主机上启动一Hyper-V虚拟机。</p><h2 id="SSH驱动"><a href="#SSH驱动" class="headerlink" title="SSH驱动"></a>SSH驱动</h2><p>当使用SSH驱动时，Minikube实际上是通过SSH在已经存在并配置好的一台远程主机上创建Kuberenetes集群。</p><h2 id="None驱动"><a href="#None驱动" class="headerlink" title="None驱动"></a>None驱动</h2><p>目前只支持Linux主机，也就是Minikube直接在当前的Linux主机上创建Kuberentes集群。</p><h1 id="创建Kubernetes集群"><a href="#创建Kubernetes集群" class="headerlink" title="创建Kubernetes集群"></a>创建Kubernetes集群</h1><h2 id="用Docker驱动快速创建一个集群"><a href="#用Docker驱动快速创建一个集群" class="headerlink" title="用Docker驱动快速创建一个集群"></a>用Docker驱动快速创建一个集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start -p mkdockerk8s --driver=docker<br></code></pre></td></tr></table></figure><p>这个命令基于Docker驱动创建了一个单节点的Kubernetes集群。参数-p用来指定集群的名字。</p><p>执行以下命令可以查看创建的集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube profile list<br></code></pre></td></tr></table></figure><p><img src="/2021/10/06/create-kubernetes-minikube/3.jpg"></p><p>执行kubectl命令可以看到集群已经被加到kubeconfig中了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl config get-contexts<br></code></pre></td></tr></table></figure><p><img src="/2021/10/06/create-kubernetes-minikube/4.jpg"></p><p>执行以下命令安装dashboard:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> metrics-server<br>minikube addons <span class="hljs-built_in">enable</span> dashboard<br></code></pre></td></tr></table></figure><blockquote><p>Dashboard的一些特性依赖于metrics-server，所以先安装metrics-server。</p></blockquote><p><strong>但是用docker driver创建的Kubernetes集群有很大的不足，基本上无法满足开发工作：</strong></p><ul><li><p>不支持ingress，当执行以下命令去安装ingress controller时，会出错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> ingress<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">❌  Exiting due to MK_USAGE: Due to networking limitations of driver docker on darwin, ingress addon is not supported.<br>Alternatively to use this addon you can use a vm-based driver:<br><br><span class="hljs-string">&#x27;minikube start --vm=true&#x27;</span><br><br>To track the update on this work <span class="hljs-keyword">in</span> progress feature please check:<br>https://github.com/kubernetes/minikube/issues/7332<br><br></code></pre></td></tr></table></figure></li><li><p>不支持LoadBalance类型的服务，执行下面命令时，也会出错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube tunnel<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">🤷  The control plane node must be running <span class="hljs-keyword">for</span> this <span class="hljs-built_in">command</span><br>👉  To start a cluster, run: <span class="hljs-string">&quot;minikube start&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>同样无法打开前面安装好的dashboard</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube dashboard<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">🤷  The control plane node must be running <span class="hljs-keyword">for</span> this <span class="hljs-built_in">command</span><br>👉  To start a cluster, run: <span class="hljs-string">&quot;minikube start&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>所以，需要通过某个Hypervisor驱动创建一个虚拟机作为Kubernetes集群的工作节点，这样既能支持ingress，又能支持Loadbalance类型的服务，同时还能打开dashboard。下面将通过VirtualBox驱动创建集群。</p><h2 id="用VirtualBox驱动创建集群"><a href="#用VirtualBox驱动创建集群" class="headerlink" title="用VirtualBox驱动创建集群"></a>用VirtualBox驱动创建集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start --cpus=4 --memory=<span class="hljs-string">&#x27;6g&#x27;</span> --cni=<span class="hljs-string">&#x27;flannel&#x27;</span> --disk-size=<span class="hljs-string">&#x27;60g&#x27;</span> --driver=<span class="hljs-string">&#x27;virtualbox&#x27;</span> --kubernetes-version=<span class="hljs-string">&#x27;v1.23.5&#x27;</span> --extra-config=apiserver.service-node-port-range=1-65535 --extra-config=controller-manager.bind-address=0.0.0.0 --extra-config=scheduler.bind-address=0.0.0.0<br></code></pre></td></tr></table></figure><p>创建了一个基于VirtualBox驱动的单节点集群。通过各个参数详细地配置了集群：</p><table><thead><tr><th>参数</th><th>用途</th></tr></thead><tbody><tr><td>–cpus&#x3D;4</td><td>指定了节点最大CPU数为4</td></tr><tr><td>–memory&#x3D;’6g’</td><td>指定了工作节点的最大内存数为6g</td></tr><tr><td>–disk-size&#x3D;’60g’</td><td>指定了节点的磁盘大小</td></tr><tr><td>-kubernetes-version&#x3D;’v1.23.5’</td><td>指定创建的集群版本为v1.23.5</td></tr><tr><td>-extra-config&#x3D;apiserver.service-node-port-range&#x3D;1-65535</td><td>通过–extra-config配置apiserver，使得运行NodePort类型的服务能够使用1-65535范围的端口</td></tr><tr><td>–extra-config&#x3D;controller-manager.bind-address&#x3D;0.0.0.0</td><td>通过–extra-config配置controller-manager，使能够从外面访问controller-manager的API</td></tr><tr><td>–extra-config&#x3D;scheduler.bind-address&#x3D;0.0.0.0</td><td>通过–extra-config配置scheduler，使能够从外面访问scheduler的API</td></tr></tbody></table><p>同样，执行以下命令可以查看创建的集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube profile list<br></code></pre></td></tr></table></figure><p><img src="/2021/10/06/create-kubernetes-minikube/5.jpg"></p><h3 id="安装MetalLB支持LoadBalancer类型的服务"><a href="#安装MetalLB支持LoadBalancer类型的服务" class="headerlink" title="安装MetalLB支持LoadBalancer类型的服务"></a>安装MetalLB支持LoadBalancer类型的服务</h3><blockquote><p>参考<a href="https://metallb.universe.tf/installation/">MetalLB官方安装和配置文档</a></p></blockquote><ul><li><p>设置kube-proxy使用ipvs模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">edit</span> <span class="hljs-string">configmap</span> <span class="hljs-string">-n</span> <span class="hljs-string">kube-system</span> <span class="hljs-string">kube-proxy</span><br></code></pre></td></tr></table></figure><p>设置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeproxy.config.k8s.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeProxyConfiguration</span><br><span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;ipvs&quot;</span><br><span class="hljs-attr">ipvs:</span><br>  <span class="hljs-attr">strictARP:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>通过minikube的metallb插件安装metallb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> metallb<br></code></pre></td></tr></table></figure></li><li><p>修改MetalLB的配置添加IP地址池<br>参考<a href="https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/">Proxies and VPNs</a>，使用VirtualBox驱动创建的基于VM的集群节点IP地址池为192.168.59.0&#x2F;24。可以从中选取一段用作给Loadbalancer类型的服务分配IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit cm config  -n metallb-system<br></code></pre></td></tr></table></figure><p>设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">apiVersion: v1<br>data:<br>  config: |<br>    address-pools:<br>    - name: default<br>      protocol: layer2<br>      addresses:<br>      - 192.168.59.200 - 192.168.59.250<br></code></pre></td></tr></table></figure><p>重启metallb controller Pod。</p></li></ul><h3 id="安装Nginx-Ingress-Controller："><a href="#安装Nginx-Ingress-Controller：" class="headerlink" title="安装Nginx Ingress Controller："></a>安装Nginx Ingress Controller：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> ingress<br></code></pre></td></tr></table></figure><blockquote><p>minikube自带的Nginx Ingress Controller插件的服务类型是NodePort，所以通过任何一个工作节点的IP就可以访问。</p></blockquote><h3 id="安装Kong-Ingress-Controller"><a href="#安装Kong-Ingress-Controller" class="headerlink" title="安装Kong Ingress Controller"></a>安装Kong Ingress Controller</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> kong<br></code></pre></td></tr></table></figure><blockquote><p>minikube自带的Kong Ingress Controller的服务类型是LoadBalancer类型，MetalLB会分配对应的IP地址。</p></blockquote><h3 id="安装dashboard"><a href="#安装dashboard" class="headerlink" title="安装dashboard"></a>安装dashboard</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> metrics-server<br>minikube addons <span class="hljs-built_in">enable</span> dashboard<br></code></pre></td></tr></table></figure><blockquote><p>Dashboard中的某些数据依赖于metrics-server。</p></blockquote><p>启动Dashboard</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube dashboard<br></code></pre></td></tr></table></figure><h3 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h3><ul><li><p>登录进工作节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube ssh<br></code></pre></td></tr></table></figure></li><li><p>查询工作节点的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube ip<br></code></pre></td></tr></table></figure></li><li><p>查看集群状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">minikube status</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="Minikbue在HTTP-x2F-HTTPS代理下的使用"><a href="#Minikbue在HTTP-x2F-HTTPS代理下的使用" class="headerlink" title="Minikbue在HTTP&#x2F;HTTPS代理下的使用"></a>Minikbue在HTTP&#x2F;HTTPS代理下的使用</h1><p>当要设置HTTP&#x2F;HTTPS代理才能上网时，需要将工作节点的主机网络地址段设置到NO_PROXY中，否则Minikube会无法访问主机里的资源。</p><blockquote><p>详细参考<a href="https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/">Proxies和VPN</a>中Proxy一节。</p></blockquote><h1 id="Minikbue在VPN下的使用"><a href="#Minikbue在VPN下的使用" class="headerlink" title="Minikbue在VPN下的使用"></a>Minikbue在VPN下的使用</h1><p>使用VPN接入公司网络或者自己的私有网络时，VPN会截获Minikube访问主机的流量从而导致无法正常访问，因为VPN会强制修改本地路由，除非公司IT同意将你的Minikube用到的网段加入VPN的白名单（这往往不现实）。解决办法是通过端口转发的方法将对主机localhost或127.0.0.1的端口访问转发到集群工作节点的对应的端口上（前提是使用VM的驱动创建的集群）。以下是针对于VirtualBox驱动创建的集群添加的端口转发规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">VBoxManage controlvm minikube natpf1 k8s-apiserver,tcp,127.0.0.1,8443,,8443<br>VBoxManage controlvm minikube natpf1 k8s-ingress,tcp,127.0.0.1,9080,,80<br>VBoxManage controlvm minikube natpf1 k8s-ingress-secure,tcp,127.0.0.1,9443,,443<br>VBoxManage controlvm minikube natpf1 docker,tcp,127.0.0.1,2376,,2376<br></code></pre></td></tr></table></figure><p>比如针对集群API Server，将VirtualBox在本机打开的8443端口转发到集群节点(VM)的8443端口(集群API Server对应的端口)。这样在kubeconfig的配置文件中就可以通过<code>https://127.0.0.1:8443</code>来访问集群API Server：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">certificate-authority:</span> <span class="hljs-string">/Users/mike/.minikube/ca.crt</span><br>    <span class="hljs-attr">extensions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">extension:</span><br>        <span class="hljs-attr">last-update:</span> <span class="hljs-string">Sat,</span> <span class="hljs-number">09</span> <span class="hljs-string">Apr</span> <span class="hljs-number">2022 18:42:47 </span><span class="hljs-string">CST</span><br>        <span class="hljs-attr">provider:</span> <span class="hljs-string">minikube.sigs.k8s.io</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.25.2</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">cluster_info</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://127.0.0.1:8443</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">minikube</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">minikube</span><br></code></pre></td></tr></table></figure><p>由于VirtualBox在Mac上是以非root账号运行的，所以只能打开本机1024以上的端口，但访问ingress暴露的HTTP&#x2F;HTTPS服务时就需要加上端口号，使用起来并不友好。可以通过包过滤防火墙建立本机80，443端口到上面ingress的9080和9443端口的转发。Mac的配置参考如下：</p><h2 id="macOS-Yosemite及以上版本"><a href="#macOS-Yosemite及以上版本" class="headerlink" title="macOS Yosemite及以上版本"></a>macOS Yosemite及以上版本</h2><p>ipfw已经从macOS Yosemite和以上版本被移除了，所以需要通过以下方法使用pf。</p><ul><li><p>创建一个锚文件<br>例如，&#x2F;etc&#x2F;pf.anchors&#x2F;minikube.nginx-ingress-controller</p></li><li><p>在&#x2F;etc&#x2F;pf.anchors&#x2F;minikube.nginx-ingress-controller锚文件中, 输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 9080<br>rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 443 -&gt; 127.0.0.1 port 9443<br><br></code></pre></td></tr></table></figure><p>确保在末尾加一行空白行，否则会报格式错误。</p></li><li><p>测试这个锚文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pfctl -vnf /etc/pf.anchors/minikube.nginx-ingress-controller<br></code></pre></td></tr></table></figure></li><li><p>将这个锚文件加到pf.conf文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /etc/pf.conf<br></code></pre></td></tr></table></figure><p>在对应的节下添加下面的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">rdr-anchor <span class="hljs-string">&quot;forwarding&quot;</span> <br>load anchor <span class="hljs-string">&quot;forwarding&quot;</span> from <span class="hljs-string">&quot;/etc/pf.anchors/minikube.nginx-ingress-controller&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>自动加载pf.conf文件<br>可以创建一个专用的启动守护进程以在启动时加载和启用配置，或者编辑当前的pf守护进程在启动时自动启用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /System/Library/LaunchDaemons/com.apple.pfctl.plist<br></code></pre></td></tr></table></figure><p>然后在以下的节中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;key&gt;ProgramArguments&lt;/key&gt;<br></code></pre></td></tr></table></figure><p>增加额外的一行字符串”-e”：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>pfctl<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-e<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-f<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/etc/pf.conf<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br></code></pre></td></tr></table></figure><p>保存后重启电脑。</p><blockquote><p>可以使用命令<code>sudo pfctl -ef /etc/pf.conf</code>手动测试这个方法（不需要重启）。<br>另外，如果不想改动配置来测试这个方法，可以执行下面的命令：<br>echo “<br>  rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 9080<br>  rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 443 -&gt; 127.0.0.1 port 9443<br>  “ | sudo pfctl -ef -</p></blockquote></li></ul><h2 id="macOS-10-9和更早版本"><a href="#macOS-10-9和更早版本" class="headerlink" title="macOS 10.9和更早版本"></a>macOS 10.9和更早版本</h2><p>执行以下命令配置端口转发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /sbin/ipfw add 102 fwd 127.0.0.1,9080 tcp from any to any 80 <span class="hljs-keyword">in</span><br>sudo /sbin/ipfw add 102 fwd 127.0.0.1,9443 tcp from any to any 443 <span class="hljs-keyword">in</span><br></code></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文旨在简单介绍Minikube，它的架构以及使用，希望能够帮助读者对Minikube有个框架性的了解，从而决定是否需要深入使用。对于Minikube更详细的用法，可以参考<a href="https://minikube.sigs.k8s.io/docs/">官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>K8s</tag>
      
      <tag>Minikube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次阿里云Kubernetes集群内部服务域名解析不稳定的排查</title>
    <link href="/2021/09/06/aliyun-coredns-issue-tracking/"/>
    <url>/2021/09/06/aliyun-coredns-issue-tracking/</url>
    
    <content type="html"><![CDATA[<p>最近，由于项目需求新建了一个阿里云托管版Kubernetes集群(Managed ACK)，但是发现部署在集群中的微服务相互调用不稳定，导致业务不可用。经过排查，最终发现添加在集群工作节点上的安全组与当前集群的安全组不一致，使得跨节点的Pod访问流量被阻止掉了。本文将详细介绍这一问题的排查过程。</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>通过以下命令在Pod中通过域名访问某个服务时，有时能正常访问，有时访问不了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..100&#125;;<span class="hljs-keyword">do</span> curl http://&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>错误大致为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Couldn<span class="hljs-string">&#x27;t resolve host xxxx</span><br></code></pre></td></tr></table></figure><p>从错误信息来看，是域名解析出了问题。用nslookup命令去检查域名解析，发现解析确实不稳定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..100&#125;;nslookup &lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><h2 id="ACK集群的结构介绍"><a href="#ACK集群的结构介绍" class="headerlink" title="ACK集群的结构介绍"></a>ACK集群的结构介绍</h2><p>在详细排查问题之前，先了解下阿里云ACK集群的结构。<a href="https://help.aliyun.com/document_detail/93689.html?spm=a2c4g.11186623.6.581.77ae30b7l5Hupx">阿里云容器服务Kubernetes版（Alibaba Cloud Container Service for Kubernetes，简称容器服务ACK）</a>包含了专有版Kubernetes（Dedicated Kubernetes）、托管版Kubernetes（Managed Kubernetes）、Serverless Kubernetes三种形态。本文讨论的是托管版ACK，结构如下：</p><p><img src="/2021/09/06/aliyun-coredns-issue-tracking/1.png"></p><p>集群的详细信息：<br><img src="/2021/09/06/aliyun-coredns-issue-tracking/2.jpeg"></p><ul><li>Pod网络类型是Flannel，CIDR: 172.20.0.0&#x2F;16。每个工作节点的最大的Pod数量为64 (ECS-1 CIDR: 172.20.0.192&#x2F;26, ECS-2 CIDR: 172.20.0.128&#x2F;26 …)</li><li>Service CIDR: 172.21.0.0&#x2F;20</li><li>系统组件CoreDNS目前有两个Pod，分别运行在两个工作节点上</li></ul><h2 id="检查前的准备"><a href="#检查前的准备" class="headerlink" title="检查前的准备"></a>检查前的准备</h2><p>分别在CoreDNS Pods所在的两个工作节点上各启动一个测试Pod：Pod(Busybox)，Service(Nginx) + Pod(Nginx)。</p><blockquote><p>将测试Pods分散在不同的工作节点上，并调度到CoreDNS Pods所在的工作节点中，这样既能测试同一节点上的CoreDNS访问，也能测试跨节点的CoreDNS访问。</p></blockquote><ul><li><p>在ECS-1主机上启动Pod(Busybox)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">busybox</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">busybox</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">kubernetes.io/os:</span> <span class="hljs-string">linux</span><br>        <span class="hljs-attr">kubernetes.io/hostname:</span> <span class="hljs-string">cn-shanghai.10.0.1.121</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">300</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">yauritux/busybox-curl:latest</span><br>          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">sh</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;sleep 36000&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过nodeSelector绑定到ECS-1主机（10.0.1.121）上。</p></blockquote></li><li><p>在ECS-2主机上启动Service(Nginx) + Pod(Nginx)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">kubernetes.io/os:</span> <span class="hljs-string">linux</span><br>        <span class="hljs-attr">kubernetes.io/hostname:</span> <span class="hljs-string">cn-shanghai.10.0.2.121</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">300</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>              <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/instance:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><blockquote><p>通过nodeSelector绑定到ECS-2主机（10.0.2.121）上。</p></blockquote></li></ul><h2 id="检查系统组件CoreDNS"><a href="#检查系统组件CoreDNS" class="headerlink" title="检查系统组件CoreDNS"></a>检查系统组件CoreDNS</h2><blockquote><p>参考官方文档 <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/">Debugging DNS Resolution</a></p></blockquote><h3 id="检查CoreDNS-Pod是否正在运行"><a href="#检查CoreDNS-Pod是否正在运行" class="headerlink" title="检查CoreDNS Pod是否正在运行"></a>检查CoreDNS Pod是否正在运行</h3><p>执行命令<code>kubectl get pods</code>验证CoreDNS Pod正在运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -l k8s-app=kube-dns -n kube-system<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAME                           READY   STATUS    RESTARTS   AGE<br>pod/coredns-849698df86-j9474   1/1     Running   0          9d<br>pod/coredns-849698df86-xl5g9   1/1     Running   0          9d<br></code></pre></td></tr></table></figure><p>如果没有看到CoreDNS Pod正在运行，可能在你当前的环境里缺省没有安装CoreDNS插件，你可能需要手动安装它。如果看到CoreDNS Pod失败，执行命令<code>kubectl describe pod</code>检查CoreDNS Pod的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe pod -l k8s-app=kube-dns -n kube-system<br></code></pre></td></tr></table></figure><h3 id="检查CoreDNS-Pod是否有运行时错误"><a href="#检查CoreDNS-Pod是否有运行时错误" class="headerlink" title="检查CoreDNS Pod是否有运行时错误"></a>检查CoreDNS Pod是否有运行时错误</h3><p>运行状态正常的Pod并不代表没有错误，有时程序会处理异常以保证服务的可用性。所以需要执行命令<code>kubectl logs</code>检查Pod的日志是否有任何可疑或异常的消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs -l k8s-app=kube-dns -n=kube-system<br></code></pre></td></tr></table></figure><p>正常的CoreDNS日志实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">.:53<br>[INFO] plugin/reload: Running configuration MD5 = 3be31de8f5d9c8e0b5a82d2b6bd5251b<br>CoreDNS-1.6.7<br>linux/amd64, go1.13.6, da7f65b<br><br>.:53<br>[INFO] plugin/reload: Running configuration MD5 = 3be31de8f5d9c8e0b5a82d2b6bd5251b<br>CoreDNS-1.6.7<br>linux/amd64, go1.13.6, da7f65b<br></code></pre></td></tr></table></figure><h3 id="检查CoreDNS服务"><a href="#检查CoreDNS服务" class="headerlink" title="检查CoreDNS服务"></a>检查CoreDNS服务</h3><p>执行命令<code>kubect get svc -l k8s-app=kube-dns -n=kube-system</code>检查CoreDNS服务是否存在。如果服务不存在，参考<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/">调试服务</a>进行排查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAME               TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                  AGE<br>service/kube-dns   ClusterIP   172.21.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   450d<br></code></pre></td></tr></table></figure><h3 id="检查CoreDNS-endpoints对象是否存在"><a href="#检查CoreDNS-endpoints对象是否存在" class="headerlink" title="检查CoreDNS endpoints对象是否存在"></a>检查CoreDNS endpoints对象是否存在</h3><p>执行命令<code>kubectl get endpoints</code>检查CoreDNS endpoints是否存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAME       ENDPOINTS                                                       AGE<br>kube-dns   172.20.0.146:53,172.20.0.205:53,172.20.0.146:9153 + 3 more...   458d<br></code></pre></td></tr></table></figure><p>如果没有检查到endpoints，参考<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/">调试服务</a>文档中的endpoints段落。</p><h3 id="检查DNS查询是否被CoreDNS处理"><a href="#检查DNS查询是否被CoreDNS处理" class="headerlink" title="检查DNS查询是否被CoreDNS处理"></a>检查DNS查询是否被CoreDNS处理</h3><p>首先，修改CoreDNS的配置添加日志插件。</p><p>执行以下命令打开CoreDNS的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit cm coredns -n kube-system<br></code></pre></td></tr></table></figure><p>在Corefile段落添加<code>log</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">apiVersion: v1<br>kind: ConfigMap<br>data:<br>  Corefile: |-<br>    .:53 &#123;<br>      <span class="hljs-built_in">log</span><br>      autopath @kubernetes<br>      cache 30<br>      errors<br>      forward . /etc/resolv.conf<br>      health<br>      kubernetes cluster.local in-addr.arpa ip6.arpa &#123;<br>        pods verified<br>        fallthrough in-addr.arpa ip6.arpa<br>      &#125;<br>      loadbalance<br>      loop<br>      prometheus :9153<br>      ready<br>      reload<br>    &#125;<br></code></pre></td></tr></table></figure><p>其次，执行以下命令打开CoreDNS Pods日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs --<span class="hljs-built_in">tail</span> 20 -f -l k8s-app=kube-dns -n kube-system | grep -E <span class="hljs-string">&quot;\&quot;A IN nginx.default.svc.cluster.local&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过grep命令仅提取域名nginx.default.svc.cluster.local的DNS查询日志，后面我们将查询这个域名。</p></blockquote><p>接下来，执行以下命令进入Pod(Busybox)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -it pod/busybox-757d9599bd-hdhhq -- sh<br></code></pre></td></tr></table></figure><p>在Pod(Busybox)中，重复查询域名nginx.default.svc.cluster.local多次，例如100次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 1 100); <span class="hljs-keyword">do</span> nslookup nginx.default.svc.cluster.local; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>检查CoreDNS Pods日志，看是否有同样次数的域名解析日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] 172.20.0.219:48418 - 4 <span class="hljs-string">&quot;A IN nginx.default.svc.cluster.local. udp 49 false 512&quot;</span> NOERROR qr,aa,rd 96 0.000179197s<br>[INFO] 172.20.0.219:59640 - 4 <span class="hljs-string">&quot;A IN nginx.default.svc.cluster.local. udp 49 false 512&quot;</span> NOERROR qr,aa,rd 96 0.000067985s<br>[INFO] 172.20.0.219:34682 - 4 <span class="hljs-string">&quot;A IN nginx.default.svc.cluster.local. udp 49 false 512&quot;</span> NOERROR qr,aa,rd 96 0.000072317s<br>[INFO] 172.20.0.219:37560 - 4 <span class="hljs-string">&quot;A IN nginx.default.svc.cluster.local. udp 49 false 512&quot;</span> NOERROR qr,aa,rd 96 0.000075455s<br>[INFO] 172.20.0.219:59156 - 4 <span class="hljs-string">&quot;A IN nginx.default.svc.cluster.local. udp 49 false 512&quot;</span> NOERROR qr,aa,rd 96 0.00006403s<br>......<br></code></pre></td></tr></table></figure><p>如果域名解析的次数少于查询的次数，说明有些解析请求没有被CoreDNS获取，客户端<code>nslookup</code>命令就会出现有时解析成功，有时解析失败的情况。这也证明了前面描述的域名解析不稳定的问题。</p><h3 id="直接调用CoreDNS的Pod-IP解析域名"><a href="#直接调用CoreDNS的Pod-IP解析域名" class="headerlink" title="直接调用CoreDNS的Pod IP解析域名"></a>直接调用CoreDNS的Pod IP解析域名</h3><p>直接使用CoreDNS Pod IP可以避免CoreDNS服务到CoreDNS Pod的代理解析。如果检查下来问题仍旧存在，说明从CoreDNS服务到CoreDNS Pod的代理解析没有问题，否则需要详细检查kube-proxy的状态。</p><p>Pod(Busybox)缺省使用CoreDNS服务IP调用CoreDNS解析域名。执行以下命令可以查看Pod(Busybox)中的DNS配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -it pod/busybox-757d9599bd-hdhhq -- <span class="hljs-built_in">cat</span> /etc/resolv.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nameserver 172.21.0.10<br>search default.svc.cluster.local svc.cluster.local cluster.local<br>options ndots:5<br></code></pre></td></tr></table></figure><p>172.21.0.10是CoreDNS的服务IP。</p><p>编辑Pod(Busybox)中的<code>/etc/resolv.conf</code>将nameserver换成同一节点上的CoreDNS Pod IP（172.20.0.205），执行以下命令检查Nginx服务域名的解析情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 1 100); <span class="hljs-keyword">do</span> nslookup nginx.default.svc.cluster.local; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>测试下来发现使用同一个节点上的CoreDNS Pod解析域名正常且稳定。</p><p>将Pod(Busybox)的nameserver换成另一个节点上的CoreDNS Pod IP（172.20.0.146），再执行上面同样的测试发现域名解析都失败了。 这个测试说明Pod(Busybox)可以访问同一节点上的CoreDNS Pod，但是不能访问另一个节点上的CoreDNS Pod，也就是跨节点的Pod之间无法访问。接下来就需要检查跨节点Pod之间的路由信息是否正确了。</p><h2 id="检查从Pod-Busybox-到不同节点上的CoreDNS-Pod（172-20-0-146）的路由信息"><a href="#检查从Pod-Busybox-到不同节点上的CoreDNS-Pod（172-20-0-146）的路由信息" class="headerlink" title="检查从Pod(Busybox)到不同节点上的CoreDNS Pod（172.20.0.146）的路由信息"></a>检查从Pod(Busybox)到不同节点上的CoreDNS Pod（172.20.0.146）的路由信息</h2><ul><li><p>Pod(Busybox)里的路由信息<br><img src="/2021/09/06/aliyun-coredns-issue-tracking/3.png"><br>从Pod(Busybox)出来的流量会通过红色的路由规则进入到节点ECS-1。</p></li><li><p>VPC里跨节点之间的路由信息<br><img src="/2021/09/06/aliyun-coredns-issue-tracking/4.png"><br>红框中的系统路由规则使两个节点之间路由可达。</p><p><img src="/2021/09/06/aliyun-coredns-issue-tracking/5.png"><br>蓝框中的路由规则使流量从ECS-1路由到ECS-2中。</p></li><li><p>ECS-2的路由信息<br><img src="/2021/09/06/aliyun-coredns-issue-tracking/6.png"><br>红色路由规则使得流量从ECS-2路由到网桥接口cni0，最终由cni0根据目的Pod IP地址进入CoreDNS Pod（172.20.0.146）。</p></li></ul><p>从路由分析下来看，跨节点Pod之前相互访问没有问题。接下来就需要检查施加在工作节点上的安全组规则，看流量是否被禁止了。</p><h2 id="检查安全组"><a href="#检查安全组" class="headerlink" title="检查安全组"></a>检查安全组</h2><p>通过这个检查，最终发现工作节点上的安全组并不是当前集群对应的安全组，从而导致所有跨节点之前的Pod访问流量被禁止了。安全组用错的原因是在新建ACK集群时并没有创建新的节点而是选择了已经存在的节点。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>找到问题后，解决方案就简单了，也就是将所有的工作节点的安全组全部换成当前集群的安全组。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>对于这次的问题定位和解决花费了一定的精力，而且这个问题未来也可能再次出现。所以，我们可以将跨节点Pod之间的网络连通性纳入到监控系统中，这样可以保证下次同样的问题出现时，能够通过监控系统快速的发现和定位问题。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AliCloud</tag>
      
      <tag>Aliyun</tag>
      
      <tag>ACK</tag>
      
      <tag>Kubernetes</tag>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析SonarQube插件的运行原理</title>
    <link href="/2021/01/17/sonar-plugin-principle/"/>
    <url>/2021/01/17/sonar-plugin-principle/</url>
    
    <content type="html"><![CDATA[<p>最近公司的某个Java项目的<a href="https://www.sonarqube.org/">SonarQube</a>静态代码扫描出了问题，虽然最终解决了，但是在排查问题的过程中走了一些弯路，多花了点时间。分析下来，主要原因还是对SonarQube插件的运行机制不是很清楚。本文从分析SonarQube扫描的问题出发简单地介绍下SonarQube插件的运行原理。</p><span id="more"></span><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>项目是用Maven构建的，Maven的<a href="https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-maven/">SonarScanner插件</a>用来做静态代码扫描。最近项目的Java版本升级到14，SonarQube扫描就遇到了下面的问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">[ERROR] Failed to execute goal org.sonarsource.scanner.maven:sonar-maven-plugin:3.7.0.1746:sonar<br>(default-cli) on project aid-range-ocean: Unsupported Java version for PMD: 14 -&gt; [Help 1]<br>[ERROR]<br>[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.<br>[ERROR] Re-run Maven using the -X switch to enable full debug logging.<br>[ERROR]<br>[ERROR] For more information about the errors and possible solutions, please read the following articles:<br>[ERROR] [Help 1]<br></code></pre></td></tr></table></figure><p>从错误日志看，PMD不支持Java14。再从下面的Sonar扫描的日志看，当前使用的PMD版本为6.10.0版本。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[INFO] Load metrics repository<br>[INFO] Load metrics repository (done) | time=268ms<br>[INFO] Sensor JavaSquidSensor [java]<br>[INFO] Sensor JavaSquidSensor [java] (done) | time=2289ms<br>[INFO] Sensor PmdSensor [pmd]<br>[INFO] Execute PMD 6.10.0<br>[INFO] Execute PMD 6.10.0 (done) | time=15ms<br></code></pre></td></tr></table></figure><p>在<a href="https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.22.0#java-14-support">PMD的GitHub网站</a>看到PMD从6.22.0版本才开始支持Java14。刚开始，最直接的想法是如何让Maven的SonarScanner插件使用新版本的PMD，所以引入了<a href="https://maven.apache.org/plugins/maven-pmd-plugin/">Maven PMD插件</a>并设置PMD的版本为6.29.0，以下是Maven的POM文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pmd.plugin.version</span>&gt;</span>3.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">pmd.plugin.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pmd.version</span>&gt;</span>6.29.0<span class="hljs-tag">&lt;/<span class="hljs-name">pmd.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-pmd-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pmd.plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sourceforge.pmd<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pmd-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pmd.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sourceforge.pmd<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pmd-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pmd.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sourceforge.pmd<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pmd-javascript<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pmd.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sourceforge.pmd<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pmd-jsp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pmd.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-pmd-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- failOnViolation is actually true by default, but can be disabled --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">failOnViolation</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">failOnViolation</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- printFailingErrors is pretty useful --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">printFailingErrors</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">printFailingErrors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">targetJdk</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-name">targetJdk</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>check<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是运行下来发现问题并没有解决，而且又多了次PMD扫描。这个扫描来自于Maven PMD插件，用的版本确实是我们设置的6.29.0版本，也确实能够支持Java14。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">[INFO] --- maven-pmd-plugin:3.14.0:check (default) @ xxxx ---<br>[INFO] PMD version: 6.29.0<br>[INFO] You have 41 PMD violations. For more details see: xxxx/target/pmd.xml<br></code></pre></td></tr></table></figure><p>所以，Maven PMD插件和Sonar扫描是没有关系的，即使没有SonarQube，Maven PMD插件也能够单独扫描Java代码。接下来，我们就把思路转到SonarQube的插件上了，而且发现SonarQube的服务端确实安装了一个<a href="https://github.com/jensgerdes/sonar-pmd">SonarQube的PMD插件</a>，且版本为3.2.1。从SonarQube PMD插件的GitHub页面看，版本3.2.1支持的PMD版本为6.9.0，确实不支持Java14, 而SonarQube的PMD插件从3.3.x版本才开始支持PMD 6.30.0版本，也就能够支持Java14。当把SonarQube的PMD插件升级为3.3.0后，问题解决了。再仔细分析客户端SonarQube扫描日志发现Maven SonarScanner插件会将SonarQube的PMD插件下载到本地缓存目录中，所以应该是Maven SonarScanner插件调用SonarQube PMD插件做PMD扫描。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">[INFO] --- sonar-maven-plugin:3.7.0.1746:sonar (default-cli) @ xxxx ---<br>[INFO] User cache: /xxxx/.sonar/cache<br>[INFO] SonarQube version: 7.9.4<br>[INFO] Default locale: &quot;en_CN&quot;, source code encoding: &quot;UTF-8&quot;<br>[INFO] Load global settings<br>[INFO] Load global settings (done) | time=1676ms<br>[INFO] Server id: 9C01C42E-1505da3410fc976<br>[INFO] User cache: /xxxx/.sonar/cache<br>[INFO] Load/download plugins<br>[INFO] Load plugins index<br>[INFO] Load plugins index (done) | time=295ms<br>[INFO] Load/download plugins (done) | time=501ms<br></code></pre></td></tr></table></figure><p>搜索了下SonarQube本地缓存目录，确实发现了SonarQube PMD插件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">/xxxx/.sonar/cache/5528f475b7c3651f5a42841b092164fa<br><br>Jan 18:58 sonar-pmd-plugin.jar<br>Jan 18:58 sonar-pmd-plugin.jar_unzip<br></code></pre></td></tr></table></figure><p>看了下SonarQube PMD插件的解压目录，它引用了PMD 6.30.0版本：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">/xxxx/.sonar/cache/5528f475b7c3651f5a42841b092164fa/sonar-pmd-plugin.jar_unzip/META-INF/lib<br><br>-rw-r--r--  1 mizha53  619956085  1241504 13 Jan 18:58 pmd-core-6.30.0.jar<br>-rw-r--r--  1 mizha53  619956085  1141858 13 Jan 18:58 pmd-java-6.30.0.jar<br></code></pre></td></tr></table></figure><p>到此，我们已经完全搞清楚SonarQube PMD扫描的调用顺序：Maven SonarScanner插件下载SonarQube PMD插件到本地缓存目录（如果不存在的话）, Maven SonarScanner插件调用SonarQube PMD插件，SonarQube PMD插件最终调用PMD完成扫描。但是SonarQube的插件仅仅是运行在客户端吗，扫描后的结果上传到服务端后如何处理，由谁来处理？答案还是SonarQube插件，SonarQube插件是对SonarQube的扩展，既可以运行在客户端也可以运行在服务端。接下来，我们就了解下SonarQube插件的原理。</p><h1 id="SonarQube插件原理"><a href="#SonarQube插件原理" class="headerlink" title="SonarQube插件原理"></a>SonarQube插件原理</h1><h2 id="SonarQube架构"><a href="#SonarQube架构" class="headerlink" title="SonarQube架构"></a>SonarQube架构</h2><p><img src="/2021/01/17/sonar-plugin-principle/1.png" alt="SonarQube架构"></p><ul><li><p>SonarQube服务包含了三个进程：</p><ul><li>Web服务给开发人员或者经理浏览代码质量快照并配置SonarQube实例</li><li>基于ElasticSearch的搜索服务支持从UI界面搜索信息</li><li>计算引擎服务负责处理代码分析报告并将它们存储在SonarQube数据库中</li></ul></li><li><p>SonarQube数据库用来存储：</p><ul><li>SonarQube实例的配置（安全，插件配置等）</li><li>项目或视图的质量快照</li></ul></li><li><p>安装在服务端的多个SonarQube插件，包括语言，SCM，集成，认证和管理插件</p></li><li><p>运行在构建或持续集成服务器上的一个多个SonarScanner用来分析项目</p></li><li><p>集成在不同IDE中的SonarLint插件，在开发人员的IDE中实时分析代码质量</p></li></ul><h2 id="SonarQube插件"><a href="#SonarQube插件" class="headerlink" title="SonarQube插件"></a>SonarQube插件</h2><p>SonarQube在以下的四个技术栈中提供了扩展点：</p><ul><li>扫描器(Scanner)，执行源代码分析</li><li>计算引擎，整合扫描器的结果</li><li>Web应用</li><li>SonarLint</li></ul><p>一个SonarQube插件可以对一个，多个或所有的技术栈实现扩展。例如，下面的SonarQube PMD插件实现了所有技术栈的扩展：<br><img src="/2021/01/17/sonar-plugin-principle/2.png" alt="SonarQube PMD插件扩展SonarQube"></p><p>每一个扩展点都是一个Java类，而一个扩展点可以同时实现多个技术栈。例如，PmdSensor即扩展了SonarLint，又扩展了SonarQube Scanner，也就是Java类PmdSensor即运行在SonarLint中，也运行在SonarScanner中。”SonarLintSide”，“ScannerSide”，“ServerSide”和“ComputeEngineSide”是Java中用来标注扩展点的Java类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ScannerSide</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PmdConfiguration</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROPERTY_GENERATE_XML</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sonar.pmd.generateXml&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PMD_RESULT_XML</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pmd-result.xml&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span> Loggers.get(PmdConfiguration.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FileSystem fileSystem;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration settings;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PmdConfiguration</span><span class="hljs-params">(FileSystem fileSystem, Configuration settings)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fileSystem = fileSystem;<br>        <span class="hljs-built_in">this</span>.settings = settings;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><p>所以，由上面SonarQube插件的分析来看，SonarQube的插件具体运行在什么地方，就看它扩展了哪些技术栈。如果它扩展了扫描器(Scanner)，那么客户端的扫描器(Scanner)在执行代码扫描的时候就会下载这个插件到本地缓存目录并执行里面的Java类。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SonarQube</tag>
      
      <tag>Code Quality</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云通过RAM角色管理多云账号下的资源</title>
    <link href="/2021/01/05/aliyun-ram-role-multi-accounts/"/>
    <url>/2021/01/05/aliyun-ram-role-multi-accounts/</url>
    
    <content type="html"><![CDATA[<p>云计算经过十几年的发展已经变得很成熟，无论是传统企业还是初创企业都将云计算平台作为其数字化策略的支撑平台。在国内，阿里云是使用最广泛的公有云平台，很多本土企业和外资企业在华的分支机构都是首选阿里云来构建和运行他们的数字化方案。为了能够高效地使用阿里云，同时又能对接阿里云产品服务团队，在这些公司里逐渐地出现了一个新的角色或团队来统一规划、管理阿里云平台，我们就暂且称这个团队为云团队。大部分公司云团队往往需要管理多个阿里云账号，而在不同的账号里的用户创建、登录、登出的操作往往会变的很麻烦。本文介绍通过切换身份的方式扮演<a href="https://help.aliyun.com/document_detail/93689.html?spm=a2c4g.11186623.6.581.77ae30b7l5Hupx">RAM角色</a>来管理多云账号下的资源。</p><span id="more"></span><h1 id="多云账号"><a href="#多云账号" class="headerlink" title="多云账号"></a>多云账号</h1><p>公司在使用阿里云的过程中，基于不同的目的或者受组织架构的约束，或多或少都会创建多个云账号。传统的公司或者绝大部分外资公司在财务上都会为不同的部门或团队创建不同的成本中心(cost center)并分配对应的预算，部门或团队的开支都是走自己的成本中心。这就决定了当某个部门或团队在使用阿里云的时候，必定会创建自己的云账号，而不会去使用别的成本中心下的阿里云账号。一些中小型的互联网公司或者创业公司的财务不会那么复杂，研发可能就一个成本中心，但是往往需要多个阿里云账号来隔离不同的环境，例如开发，测试，预生产和和生产环境。</p><p>使用多个阿里云账号有以下一些优点：</p><ul><li>不同账号的云资源是完全隔离的，相互之间不受影响。</li><li>可以单独出账单，做到按不同成本中心核算。</li><li>如果构建的微服务系统涉及到多个业务部门或团队，各个业务部门或团队在自己的阿里云账号里只维护或运行自己负责的微服务，这样可以降低单个阿里云账号下架构的复杂性。</li></ul><p>但是云团队在管理多个阿里云账号时也会遇到很多麻烦：</p><ul><li>需要重复地登录，登出和双因素认证来切换不同的账号。</li><li>阿里云支持单点登录(SSO)，这样可以省掉双因素认证的步骤，但当出现问题时，无法创建一个非SSO账号给阿里云技术支持用来临时登录进账号调试问题。</li><li>团队成员入职，离职时都需要通知产品拥有者在阿里云账号里创建和删除RAM用户。</li><li>每个云团队成员都需要需要记住很多云账号。</li></ul><h1 id="通过RAM角色管理多云账号"><a href="#通过RAM角色管理多云账号" class="headerlink" title="通过RAM角色管理多云账号"></a>通过RAM角色管理多云账号</h1><p>为了解决多云账号管理的痛点，可以通过RAM用户扮演RAM角色的方式来登录阿里云其它账号。</p><h2 id="什么是RAM角色"><a href="#什么是RAM角色" class="headerlink" title="什么是RAM角色"></a>什么是RAM角色</h2><p>RAM角色（RAM role）与RAM用户一样，都是RAM身份类型的一种。RAM角色是一种虚拟用户，没有确定的身份认证密钥，需要被一个受信的实体用户扮演才能正常使用。</p><p>RAM角色是一种虚拟用户，与实体用户（云账号、RAM用户和云服务）和教科书式角色（Textbook role）不同。</p><ul><li>实体用户：拥有确定的登录密码或访问密钥。</li><li>教科书式角色：教科书式角色或传统意义上的角色是指一组权限集合，类似于RAM里的权限策略。如果一个用户被赋予了这种角色，也就意味着该用户被赋予了一组权限，可以访问被授权的资源。</li><li>RAM角色：RAM角色有确定的身份，可以被赋予一组权限策略，但没有确定的登录密码或访问密钥。RAM角色需要被一个受信的实体用户扮演，扮演成功后实体用户将获得RAM角色的安全令牌，使用这个安全令牌就能以角色身份访问被授权的资源。</li></ul><h2 id="RAM角色使用方法"><a href="#RAM角色使用方法" class="headerlink" title="RAM角色使用方法"></a>RAM角色使用方法</h2><ul><li><p>RAM角色指定可信实体，即指定可以扮演角色的实体用户身份。</p></li><li><p>可信实体通过控制台或调用API扮演角色并获取角色令牌。<br><img src="/2021/01/05/aliyun-ram-role-multi-accounts/6.png"></p></li><li><p>为RAM角色绑定权限策略。</p></li><li><p>受信实体通过扮演角色，使用角色令牌访问阿里云资源。</p></li></ul><h2 id="RAM角色类型"><a href="#RAM角色类型" class="headerlink" title="RAM角色类型"></a>RAM角色类型</h2><p>根据RAM可信实体的不同，RAM支持以下三种类型的角色：</p><ul><li><p>阿里云账号：允许RAM用户所扮演的角色。扮演角色的RAM用户可以属于自己的云账号，也可以属于其他云账号。此类角色主要用来解决跨账号访问和临时授权问题。</p></li><li><p>阿里云服务：允许云服务所扮演的角色。此类角色主要用于授权云服务代理您进行资源操作。</p></li><li><p>身份提供商：允许受信身份提供商下的用户所扮演的角色。此类角色主要用于实现与阿里云的SSO。</p></li></ul><h2 id="RAM角色切换的方式管理多云账号的实现"><a href="#RAM角色切换的方式管理多云账号的实现" class="headerlink" title="RAM角色切换的方式管理多云账号的实现"></a>RAM角色切换的方式管理多云账号的实现</h2><p>实现多云账号管理需要满足以下的前提条件：</p><ul><li><p>云团队拥有自己的云账号，假设账号ID为123456789012****，每个成员都有对应的RAM用户。</p></li><li><p>假设某个业务部门的云账号为128888789012****。</p></li></ul><h3 id="实现架构"><a href="#实现架构" class="headerlink" title="实现架构"></a>实现架构</h3><p><img src="/2021/01/05/aliyun-ram-role-multi-accounts/7.png" alt="RAM用户通过扮演不同云账号里的RAM角色来管理账号里的资源"></p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li><p>产品拥有者参考“<a href="https://help.aliyun.com/document_detail/93691.html?spm=a2c4g.11186623.6.584.312068f9HVtYvh">创建可信实体为阿里云账号的RAM角色</a>”，在自己的云账号下为云团队的账号123456789012****创建RAM角色”CloudAdmin”，并给角色分配”AdministratorAccess”权限<br><img src="/2021/01/05/aliyun-ram-role-multi-accounts/1.png" alt="选择授信实体为阿里云账号"><br><img src="/2021/01/05/aliyun-ram-role-multi-accounts/2.png" alt="选择其它云账号，并输入云团队的账号"><br><img src="/2021/01/05/aliyun-ram-role-multi-accounts/3.png" alt="给这个RAM角色授予管理员权限"></p></li><li><p>设置以下授信策略。授信实体为云团队的账号“123456789012****”，并开放给有“AliyunSTSAssumeRoleAccess”权限的RAM用户</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRole&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;RAM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;acs<span class="github-emoji" alias="ram" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span>:123456789012****:root&quot;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>也可以将某个授信实体限制为账号下的某个RAM用户，比如mikejianzhang</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRole&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;RAM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;acs<span class="github-emoji" alias="ram" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span>:123456789012****:user/mikejianzhang&quot;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>云团队在自己的云账号里为RAM用户授予角色扮演权限”AliyunSTSAssumeRoleAccess”。</p></li><li><p>云团队的某个RAM用户首先登录云团队的账号，然后通过切换角色并输入业务部门云账号或者别名，以及对应的角色”CloudAdmin”就能切换进业务部门云账号里。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/4.png"></div><div class="group-image-wrap"><img src="/5.png" alt="输入业务部门云账号ID或别名"></div></div><div class="group-image-row"></div></div></li><li><p>完成管理任务后点击“返回登录身份”退回到自己的账号。<br><img src="/2021/01/05/aliyun-ram-role-multi-accounts/8.png"></p></li><li><p>当有云团队成员入职或离职时，只需要在云团队的阿里云账号里添加和删除对应的RAM用户即可。</p></li></ul><p>这样，通过RAM角色切换的方法，云团队就可以管理多个业务部门的云账号。另外，RAM角色切换的方法还有以下两个使用场景：</p><ul><li>通过RAM角色临时授权给阿里云的技术支持帮助调试问题，尤其是在云账号开启了单点登录(SSO)的情况下，只有通过这种方法才能让阿里云的技术支持登录进来。</li><li>当一个企业希望将部分业务授权给另一个企业时，也可以通过RAM角色进行跨阿里云账号授权来管理资源的访问。例如，企业A购买了多种阿里云资源（ECS实例、RDS实例、SLB实例等），但是企业A希望能专注于业务，仅作为资源拥有者。企业A希望可以授权企业B账号来对云资源进行运维，监控和管理，企业A也希望企业B的员工入职和离职时，无需做任何权限变更，同时也希望合同终止时，可以随时撤销对企业B的授权。这种情况下，企业A可以创建一定权限的角色并授权给企业B的阿里云账号，企业B的RAM用户可以通过角色切换的方法登录进企业A的账号对资源进行运维管理。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>AliCloud</tag>
      
      <tag>Aliyun</tag>
      
      <tag>RAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git安装与配置</title>
    <link href="/2020/12/31/git-install-configure/"/>
    <url>/2020/12/31/git-install-configure/</url>
    
    <content type="html"><![CDATA[<p><a href="https://git-scm.com/">Git</a>是目前使用最广泛的分布式版本管理系统。相对于集中式代码管理系统，例如Subversion, Perforce等，来说，它有着无法比拟的优势，比如轻量级的分支管理，适合不同场景的分支合并策略，离线状态下的版本管理和变更历史查询等，而这些优势也正好符合了当前敏捷和精益的软件开发方法。本文将介绍如何在Linux，Mac和Windows系统中安装并配置Git。</p><span id="more"></span><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>本文只介绍Git命令行的安装，因为使用命令行更能掌握Git的本质，且对于DevOps或系统维护人员来说，使用命令行也是日常的基本功。当掌握了Git命令行的使用后，再去使用图形化客户端，也会变得更容易。</p><h2 id="在Mac中的安装"><a href="#在Mac中的安装" class="headerlink" title="在Mac中的安装"></a>在Mac中的安装</h2><p>Mac Xcode自带了Git。如果你的Mac电脑上已经安装了Xcode，就已经有Git可以使用了，Git命令的安装路径为&#x2F;usr&#x2F;bin&#x2F;git。但是这个Git不一定是比较新的版本，可以通过Homebrew或第三方提供的DMG安装包，重新安装一个比较新的版本。</p><ul><li><p>通过Homebrew安装</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install git<br></code></pre></td></tr></table></figure><p>  Homebrew将Git安装在&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;git&#x2F;2.29.2&#x2F;路径下，同时会建立一个符号链接&#x2F;usr&#x2F;local&#x2F;bin&#x2F;git指向Git命令&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;git&#x2F;2.29.2&#x2F;bin&#x2F;git。2.29.2是当前Homebrew支持的最新版本。</p><blockquote><p>在PATH环境变量中确保路径&#x2F;usr&#x2F;local&#x2F;bin在&#x2F;usr&#x2F;bin之前，这样Homebrew安装的Git命令会被优先使用。</p></blockquote></li><li><p>通过DMG安装包安装</p><p>  可以从<a href="https://sourceforge.net/projects/git-osx-installer/">https://sourceforge.net/projects/git-osx-installer/</a> 下载较新的版本去安装。通过DMG安装的Git被安装在&#x2F;usr&#x2F;local&#x2F;git下, 并且会在&#x2F;usr&#x2F;local&#x2F;bin和&#x2F;usr&#x2F;share&#x2F;man&#x2F;中建立符号链接。</p><p>  可以通过下面的命令卸载Git.</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo /usr/local/git/uninstall.sh<br></code></pre></td></tr></table></figure></li></ul><div class="note note-info">            <p>推荐用Homebrew的方式安装Git，不但能获得较新的版本，而且以后升级也方便。</p>          </div><h2 id="在Linux中的安装"><a href="#在Linux中的安装" class="headerlink" title="在Linux中的安装"></a>在Linux中的安装</h2><p>Linux系统也缺省自带了Git，不过一般不是最新的版本，但不影响使用。如果想安装最新版本或相对较新的版本的话，可以参照下面方法安装。</p><h3 id="在Ubuntu中安装最新版本的Git"><a href="#在Ubuntu中安装最新版本的Git" class="headerlink" title="在Ubuntu中安装最新版本的Git"></a>在Ubuntu中安装最新版本的Git</h3><p>Ubuntu自带的Git是安装在路径&#x2F;usr&#x2F;bin&#x2F;git下。在Ubuntu中，可以通过<a href="https://launchpad.net/ubuntu/+ppas">PPA（Personal Package Archive）</a>安装最新版本的Git，安装完后会覆盖旧的版本。以下是安装步骤：</p><ul><li><p>添加Git的PPA库</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo add-apt-repository ppa:git-core/ppa<br></code></pre></td></tr></table></figure></li><li><p>更新APT缓存</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br></code></pre></td></tr></table></figure></li><li><p>搜索最新版本的Git</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-cache madison git<br></code></pre></td></tr></table></figure></li><li><p>安装Git</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install git<br></code></pre></td></tr></table></figure></li></ul><div class="note note-info">            <p>这里选择的是Ubuntu18。</p>          </div><h3 id="在CentOS中安装最新版本的Git"><a href="#在CentOS中安装最新版本的Git" class="headerlink" title="在CentOS中安装最新版本的Git"></a>在CentOS中安装最新版本的Git</h3><p>CentOS 7自带的Git非常旧，还是1.x的版本，执行<code>rpm -qa | grep git</code>可以看到Git包为”git-1.8.3.1-23.el7_8.x86_64“，安装路径为&#x2F;usr&#x2F;bin&#x2F;git。在CentOS中，可以通过Endpoint仓库安装最新版本的Git。以下是安装步骤：</p><ul><li><p>删除旧的Git</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum remove git*<br></code></pre></td></tr></table></figure></li><li><p>添加CentOS 7 Endpoint仓库</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum -y install https://packages.endpoint.com/rhel/7/os/x86_64/endpoint-repo-1.7-1.x86_64.rpm<br></code></pre></td></tr></table></figure></li><li><p>更新Yum缓存</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum update<br></code></pre></td></tr></table></figure></li><li><p>搜索最新版本的Git</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum list git<br></code></pre></td></tr></table></figure></li><li><p>安装Git</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install git<br></code></pre></td></tr></table></figure></li></ul><div class="note note-info">            <p>这里选择的是CentOS 7。</p>          </div><h2 id="在Windows中的安装"><a href="#在Windows中的安装" class="headerlink" title="在Windows中的安装"></a>在Windows中的安装</h2><p>从<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 下载最新版本的Windows安装包，并安装。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/1.png" class=""></div><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/2.png" class=""></div><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/3.png" class=""></div><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/4.png" class=""></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/5.png" class=""></div><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/6.png" class=""></div><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/7.png" class=""></div><div class="group-image-wrap"><img src="/2020/12/31/git-install-configure/8.png" class=""></div></div></div><div class="note note-info">            <p>尽量选择红色框里的选项，这样能最大限度地用Linux的方式使用Git命令。</p>          </div><h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><p>为了更好地使用Git命令行客户端，需要做一些必要的设置，有些设置是不同平台共享的，有些设置是平台独有的。</p><h2 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h2><ul><li><p>设置用户名和邮件地址</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name mikejianzhang<br>git config --global user.email mikejianzhang@163.com<br></code></pre></td></tr></table></figure></li><li><p>设置引用路径为false</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>如果文件名或路径中含有非英文字符或者允许的控制字符，例如中文字符，反斜杠，双引号等，当不设置”core.quotepath”或者设置它的值为true时，Git命令在显示这些文件名或路径时会用双引号引用这些文件名或路径，并对这些字符进行转义显示，即对非英文字符用八进制格式显示UTF-8编码，而对控制字符则通过反斜杠进行转义，当设置”core.quotepath”为false时，则对非英文字符会显示原来的文本，但是对控制字符仍然会转义显示。  </p><p>下面的两个文件名中既包含了中文字符又包含了控制字符，反斜杠和双引号。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">mikepro:git-test mike$ <span class="hljs-built_in">ls</span> -l<br>total 16<br>-rw-r--r--  1 mike  staff  12 Jan  1 19:33 你好\上海 <span class="hljs-string">&quot;大家们&quot;</span>.txt<br>-rw-r--r--  1 mike  staff  13 Jan  1 19:28 你好祖国.txt<br></code></pre></td></tr></table></figure><p>当不设置”core.quotepath”或者设置它的值为true时，<code>git status</code>显示如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">mikepro:git-test mike$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br>    &quot;\344\275\240\345\245\275\\\344\270\212\346\265\267 \&quot;\345\244\247\345\256\266\344\273\254\&quot;.txt&quot;<br>    &quot;\344\275\240\345\245\275\347\245\226\345\233\275.txt&quot;<br></code></pre></td></tr></table></figure><p>当设置”core.quotepath”为false时，<code>git status</code>显示如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">mikepro:git-test mike$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br>    &quot;你好\\上海 \&quot;大家们\&quot;.txt&quot;<br>    你好祖国.txt<br></code></pre></td></tr></table></figure>          </div></li><li><p>设置永久缓存Git账号</p><p>  当通过http协议访问Git仓库时，需要提供用户名和密码，为了避免每次都要输入用户名和密码，可以设置永久缓存Git账号。</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global credential.helper store<br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>在Mac系统中，账号会被缓存到Keychain里，而在Linux&#x2F;Windows中，账号会被缓存到文件~&#x2F;.git-credentials中。</p>          </div></li><li><p>设置安全的换行符</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.safecrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>严格检查文本或代码文件的换行符是否正确，例如在Linux&#x2F;Mac&#x2F;Unix平台上，应该都是LF格式，在Windows平台上，应该是CRLF格式，或者是在.gitattribute中，通过选项”eol“显式指定的换行符，如果不正确则阻止提交。</p>          </div></li><li><p>设置忽略ssl证书验证</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global http.sslverify <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>如果Git通过http协议访问代码仓库，可以设置忽略ssl证书验证，尤其是Git服务器用的是自签名证书。</p>          </div></li><li><p>设置空格处理</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.whitespace cr-at-eol,-trailing-space<br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>在执行<code>git diff</code>和<code>git apply</code>命令时，如何处理空格或换行很重要，否则在团队协同开发的过程中会产生很大的干扰。</p><p>cr-at-eol: 如果行尾为CR字符，当做换行符处理，不显示^M<br>-trailing-space: 执行<code>git apply</code>时，对于行末或文末的空格不提示错误</p>          </div></li></ul><h2 id="Linx-x2F-Mac中的配置"><a href="#Linx-x2F-Mac中的配置" class="headerlink" title="Linx&#x2F;Mac中的配置"></a>Linx&#x2F;Mac中的配置</h2><ul><li><p>设置文件检出时的换行符</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.autocrlf input<br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>在Linx&#x2F;Mac系统中，从代码仓库检出文件时，保持服务端的文件换行符，因为Git服务端是按照Linux格式的换行符存储文本或代码文件的。</p>          </div></li></ul><h2 id="Windows中的配置"><a href="#Windows中的配置" class="headerlink" title="Windows中的配置"></a>Windows中的配置</h2><ul><li><p>设置文件检出时的换行符</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.autocrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>在Windows系统中，从代码仓库检出文件时，将文本或代码文件的换行符自动转换成Windows格式的换行符CRLF，除非在.gitattribute中显式指定某些文件的换行符为Linux格式的换行符LF。</p>          </div></li><li><p>设置允许长路径文件</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.longpaths <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>  <div class="note note-info">            <p>设置Windows中的Git命令支持长路径（大于260字节）。</p>          </div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git加密存储文件</title>
    <link href="/2020/12/16/git-encrypt-file-in-repository/"/>
    <url>/2020/12/16/git-encrypt-file-in-repository/</url>
    
    <content type="html"><![CDATA[<p>不要将包含用户名、密码、API令牌(Token)等各类敏感信息放在Git代码仓库中已经成为了大家的共识，尤其是代码仓库托管在GitHub、GitLab、Bitbucket等提供公共代码仓库服务的平台上时，更需要且值得任何的代价去尽量避免这种事情的发生。本文介绍并使用<a href="https://git-secret.io/">git-secret</a>将文件加密后存储在Git代码仓库中，以及基于git-secret的多人协同工作的流程。</p><span id="more"></span><h1 id="私有仓库是否安全"><a href="#私有仓库是否安全" class="headerlink" title="私有仓库是否安全"></a>私有仓库是否安全</h1><p>也许有人会说：”我把代码仓库设成私有的不就安全了？“，然而情况并非如此，因为即使是私有仓库，也同样面临着不同类型的风险。当你集成某个第三方服务到你的私有仓库（比如集成第三方的持续集成服务）时，你的私有仓库就开放给了第三方服务，这些第三方服务就有可能读取你存储在代码仓库中的敏感信息。如果第三方服务遭受了黑客攻击，那么黑客就可以通过这个第三方服务获取你的Git仓库中的敏感信息。</p><h1 id="为什么还要将敏感信息放在Git代码仓库中"><a href="#为什么还要将敏感信息放在Git代码仓库中" class="headerlink" title="为什么还要将敏感信息放在Git代码仓库中"></a>为什么还要将敏感信息放在Git代码仓库中</h1><p>正如文初谈到的”不要将敏感信息放在Git代码仓库中已是共识“，那为什么还用谈将敏感信息放在Git代码仓库中？正所谓无风不起浪，存在即合理。抛开敏感信息这个特征不谈，包含这些信息的文件其实和我们的代码文件没什么区别，如果不放在Git仓库中，就不能对它们做版本管理，比如对文件名和路径的变更，密码等敏感信息的变更，新信息的添加等都没法追踪它们的变更记录，尤其在构建一个自动部署系统时，你就不得不维护一个额外的安全服务来加密存储这些包含敏感信息的配置文件，而自动部署系统也需要设计额外的方法和步骤来读取这些配置文件，更为麻烦的是自动部署系统无法通过Git变更记录来指定使用的配置文件的版本。</p><h1 id="git-secret的原理"><a href="#git-secret的原理" class="headerlink" title="git-secret的原理"></a>git-secret的原理</h1><p>既要将包含敏感信息的配置文件保存在Git代码仓库中（能带来很多便利），又要保证安全，那么最直接的做法就是将这些文件加密后再保存到Git仓库中，而git-secret则满足了这一需求，同时git-secret也能保证多人协同工作。以下是git-secret提供的一些功能：</p><ul><li><p>利用<a href="http://www.gnupg.org/">GnuPG</a>的多密钥加密功能：多个公钥加密文件，不同的私钥解密文件。这样，工作在Git仓库中的开发人员只需要将自己的公钥保存在代码仓库中用来加密文件，同时在自己的工作机器上保存自己的私钥来解密文件。</p></li><li><p>通过git-secret将包含敏感信息的文件放入.gitignore文件中避免误提交，同时生成一个新的加密文件（在原有文件名上添加了一个额外的后缀.secret）并保存在Git仓库中。</p></li><li><p>当把代码仓库克隆到本地（只包含带有后缀.secret的加密文件）后，可以通过git-secret解密后生成解密文件（不包含.secret后缀），这样就可以在本地使用包含这些敏感信息的文件了。</p></li></ul><h1 id="git-secret的安装和使用"><a href="#git-secret的安装和使用" class="headerlink" title="git-secret的安装和使用"></a>git-secret的安装和使用</h1><p>git-secret的使用依赖于git和<a href="http://www.gnupg.org/">GnuPG</a>。Git的安装可以参考相关文档，不在这里赘述。git-secret使用的密钥以及加解密的功能都是通过GnuPG来完成的。</p><h2 id="安装GnuPG"><a href="#安装GnuPG" class="headerlink" title="安装GnuPG"></a>安装GnuPG</h2><p>GnuPG，也称为GPG，是OpenPGP标准RFC4880（也称为PGP）的免费实现。GnuPG允许你对数据和通信进行加密和签名，它具有通用的密钥管理系统，以及用于各种公钥目录的访问模块。GnuPG是一种命令行工具，具有易于与其他应用程序集成的功能。GnuPG也提供了大量的前端应用程序和库，GnuPG还提供对S&#x2F;MIME和Secure Shell（ssh）的支持。</p><ul><li><p>Mac OSX中的安装</p><p>目前最新版本的GnuPG是2.2.25。可以从<a href="https://sourceforge.net/p/gpgosx/docu/Download/">https://sourceforge.net/p/gpgosx/docu/Download/</a> 下载dmg文件并安装，也可以通过下面的brew命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install gpg2<br></code></pre></td></tr></table></figure><p>推荐使用brew的安装方式，以后可以方便升级。</p></li><li><p>Windows中的安装</p><p>Gpg4win是Windows版本的GnuPG完整实现。可以从<a href="https://gpg4win.org/download.html">https://gpg4win.org/download.html</a> 下载安装文件并安装。</p></li><li><p>Linux中的安装 </p><p>大部分Linux系统已经自带GnuPG了，所以不需要再额外安装，只是有可能不是最新版本的，但是不影响使用。如果GnuPG不存在，也可以通过以下的命令来安装：</p><p>Debian或Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install gnupg<br></code></pre></td></tr></table></figure><p>RedHat或CentOS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install gnupg<br></code></pre></td></tr></table></figure></li></ul><h2 id="安装git-secret"><a href="#安装git-secret" class="headerlink" title="安装git-secret"></a>安装git-secret</h2><p>在Max OSX和Linux中的安装可以参考git-secret的<a href="https://git-secret.io/installation">安装文档</a>。</p><ul><li><p>Mac OSX中的安装</p><p>通过brew安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git-secret<br></code></pre></td></tr></table></figure></li><li><p>Linux中的安装</p><p>Ubuntu或者Debian</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://dl.bintray.com/sobolevn/deb git-secret main&quot;</span> | sudo <span class="hljs-built_in">tee</span> -a /etc/apt/sources.list<br>wget -qO - https://api.bintray.com/users/sobolevn/keys/gpg/public.key | sudo apt-key add -<br>sudo apt-get update &amp;&amp; sudo apt-get install git-secret<br></code></pre></td></tr></table></figure><p>RedHat或者CentOS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://bintray.com/sobolevn/rpm/rpm -O bintray-sobolevn-rpm.repo<br>sudo <span class="hljs-built_in">mv</span> bintray-sobolevn-rpm.repo /etc/yum.repos.d/<br>sudo yum install git-secret<br></code></pre></td></tr></table></figure></li><li><p>Windows中的安装</p><p>git-secret官方并没有宣称支持Windows系统，但是从源代码来看已经支持CYGWIN或MINGW环境了。经过试验，以下方法可用：</p><p>(1) 首先，在Windows系统中国安装Git时，选择”在命令提示符下使用Git和可选的Unix工具“，这样可以安装和使用很多可用的Linux命令</p><p><img src="/2020/12/16/git-encrypt-file-in-repository/1.png"></p><p>(2) 将Mac OSX下通过brew安装的git secret打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -r -9 git-secret.zip /usr/local/Cellar/git-secret/<br></code></pre></td></tr></table></figure><p>(3) 将git-secret.zip拷贝到Windows系统某个目录下并解压，例如解压后的路径如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-function">C:\<span class="hljs-title">Users</span>\<span class="hljs-title">Administrator</span>\<span class="hljs-title">Documents</span>\<span class="hljs-title">Tools</span>\<span class="hljs-title">git</span>-<span class="hljs-title">secret</span>\0.3.3</span><br></code></pre></td></tr></table></figure><blockquote><p>0.3.3是git-secret的版本，可能会有变化。</p></blockquote><p>(4) 将git-secret目录下的bin目录加到Windows的Path环境变量中</p><p><img src="/2020/12/16/git-encrypt-file-in-repository/2.png"></p><p>(5) 重新启动一个命令行控制台执行以下命令检查git secret命令可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret --version<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用git-secret"><a href="#使用git-secret" class="headerlink" title="使用git-secret"></a>使用git-secret</h2><h3 id="初次添加对git-secret支持"><a href="#初次添加对git-secret支持" class="headerlink" title="初次添加对git-secret支持"></a>初次添加对git-secret支持</h3><ul><li><p>执行下面的命令创建GPG公钥和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --full-generate-key<br></code></pre></td></tr></table></figure><blockquote><p>选择缺省的加密算法“(1) RSA and RSA (default)”。<br>输入uid和email，例如分别为mikejianzhang和<a href="mailto:&#x6d;&#x69;&#107;&#x65;&#x6a;&#x69;&#97;&#110;&#x7a;&#x68;&#x61;&#x6e;&#103;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#109;">&#x6d;&#x69;&#107;&#x65;&#x6a;&#x69;&#97;&#110;&#x7a;&#x68;&#x61;&#x6e;&#103;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a>。</p></blockquote></li><li><p>导出GPG公钥和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --<span class="hljs-built_in">export</span> mikejianzhang@163.com &gt; mikejianzhang.public-key.gpg<br>gpg --armor --export-secret-key  mikejianzhang@163.com &gt; mikejianzhang.private-key.gpg<br></code></pre></td></tr></table></figure><blockquote><p>如果还有第二个开发电脑，则需要在电脑里安装Git和GnuPG，并执行下面命令导入自己的私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --import mikejianzhang.private-key.gpg<br></code></pre></td></tr></table></figure></blockquote></li><li><p>初始化一个新的Git仓库或者克隆一个已经存在的代码仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> test-git-secret<br><span class="hljs-built_in">cd</span> test-git-secret<br>git init<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/mikejianzhang/test-git-secret.git<br></code></pre></td></tr></table></figure></li><li><p>初始化Git仓库支持git-secret</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> test-git-secret<br>git secret init<br></code></pre></td></tr></table></figure><blockquote><p>类似于.git目录，git secret init命令会在根目录下创建一个.gitsecret目录用来存储GPG公钥。</p></blockquote></li><li><p>将自己的公钥导入进git secret的密钥串中（保存在.gitsecret目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret tell mikejianzhang@163.com<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令添加需要加密的文件</p><p>执行命令之前，你需要创建一个包含敏感信息的文件，而且还没有提交到Git仓库中，例如test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret add <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><blockquote><p>文件“test”会被加入到.gitignore文件中，这样Git命令就会忽略这个文件</p></blockquote></li><li><p>执行下面命令加密所有通过git secret add添加的待加密文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret hide <br></code></pre></td></tr></table></figure><blockquote><p>这个命令会产生一个加密文件，例如”test.secret”。</p></blockquote></li><li><p>将所有本地文件和文件夹提交到Git仓库中</p></li></ul><h3 id="编辑已加密后的文件"><a href="#编辑已加密后的文件" class="headerlink" title="编辑已加密后的文件"></a>编辑已加密后的文件</h3><ul><li><p>克隆Git代码仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/mikejianzhang/test-git-secret.git<br></code></pre></td></tr></table></figure></li><li><p>解密所有的加密文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret reveal -f<br></code></pre></td></tr></table></figure><blockquote><p>“-f”选项将解密后的文件强制覆盖本地的明文文件。</p></blockquote></li><li><p>编辑本地的明文文件并执行下面命令重新加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret hide<br></code></pre></td></tr></table></figure></li><li><p>将所有的本地改动提交的Git仓库中</p><blockquote><p>当每次有改动时，可以通过下面命令检查是否有加密文件的改动，以决定是否需要执行git secret hide命令去重新加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret changes<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="添加第二个用户"><a href="#添加第二个用户" class="headerlink" title="添加第二个用户"></a>添加第二个用户</h3><ul><li><p>拿到第二个用户的公钥文件，例如user2.public-key.gpg, 并执行以下的操作将第二个用户的公钥导入git仓库的密钥串中<br>执行以下命令先将用户的公钥导入gpg的密钥串中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --import user2.public-key.gpg<br></code></pre></td></tr></table></figure><p>在当前代码仓库下执行以下命令将用户的公钥从gpg的密钥串中导入git仓库的密钥串中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tell &lt;user2&gt;@xxx.com<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令解密出所有最新的加密文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret reveal -f<br></code></pre></td></tr></table></figure></li><li><p>用目前密钥串中的所有公钥（包含第二个用户的公钥）重新加密所有的文件并提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secret hide<br></code></pre></td></tr></table></figure></li></ul><p>当做完以上所有的操作后，第二个用户就可以执行git secret命令进行正常的加解密操作了。</p><h1 id="git-secret对CI-x2F-CD流程的支持"><a href="#git-secret对CI-x2F-CD流程的支持" class="headerlink" title="git-secret对CI&#x2F;CD流程的支持"></a>git-secret对CI&#x2F;CD流程的支持</h1><p>申请一个服务账号（一般企业都会支持这样的操作）包含邮箱地址，利用这个邮箱地址创建一个GnuPG的公钥和私钥，将公钥导入Git仓库的密钥环中，将私钥导入所有的构建机器中，最后在CI&#x2F;CD脚本执行构建，测试和部署前用git secret命令来解密所有的加密的文件。</p><h1 id="git-secret的缺点"><a href="#git-secret的缺点" class="headerlink" title="git-secret的缺点"></a>git-secret的缺点</h1><ul><li><p>无法在Web界面上浏览加密文件内容或做差异化比较，只有把代码仓库克隆到本地解密后才能浏览文件内容或做差异化比较。如果git-secret能够提供加密部分文件内容的功能，那么就比较完美了。例如，在一个配置文件里用正则表达式或Glob语法来定义需要加密的文本，git-secret的hide命令可以读取这个配置文件去加密文件内容而非整个文件。</p></li><li><p>操作变得复杂了。个人觉得这也不能算什么缺点，有得必有失，获得了高安全性，而在操作上就必定要花费一些代价，但这也是我们愿意花费代价去做这件事的。</p></li><li><p>用户还是需要一个安全的工具来妥善保存自己的私钥，开源和商业领域都有相关的工具选择，所以问题也不是很大。</p></li></ul><h1 id="其它的同类工具"><a href="#其它的同类工具" class="headerlink" title="其它的同类工具"></a>其它的同类工具</h1><p>除了git-secret, 还有很多其它类似的工具可供选择，它们的原理基本上都是相似的。下面列出一些仅供参考。</p><ul><li><p><a href="https://www.agwa.name/projects/git-crypt/">git-crypt</a><br>另一个和git-secret相似的方案是git-crypt，但是git-crypt是二进制可执行文件而不是shell脚本。</p></li><li><p><a href="https://github.com/StackExchange/blackbox">BlackBox</a><br>BlackBox既支持Git也支持其它的版本管理系统，例如Mercurial和Subversion。BlackBox支持加密某个文本串而不是整个文件，这正好可以弥补git-secret只能加密整个文件的缺点。可以抽空做个深入研究看BlackBox是否支持git-secret其它的一些操作。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Git仓库中永久清理脏数据</title>
    <link href="/2020/09/26/git-clean-bad-data-from-history/"/>
    <url>/2020/09/26/git-clean-bad-data-from-history/</url>
    
    <content type="html"><![CDATA[<p>在代码开发的过程中，有时会将不该提交的文件误提交到Git仓库中，比如编译产生的临时二进制文件（忘了添加.gitignore），或者包含账号，密码等敏感信息的文件。临时的二进制文件放在Git仓库中没有意义，而且如果频繁改动的话，也会导致Git仓库逐渐变大，而敏感信息会导致信息泄露且不符合信息安全标准。这些不该提交的文件或内容被称为Git仓库的脏数据，需要被清理掉。重新提交一个新的变更来清理这些脏数据是远远不够的，因为从历史版本中仍然能够找到它们。本文将介绍如何使用开源工具<a href="https://rtyley.github.io/bfg-repo-cleaner">BFG Repo-Cleaner</a>从Git仓库的变更历史中永久清除这些脏数据。</p><span id="more"></span><p>如果不借助第三方工具，要实现从Git仓库中永久清理脏数据，就需要使用Git的高级命令<a href="https://git-scm.com/docs/git-filter-branch">“git-filter-branch”</a>重写历史记录。”git-filter-branch”功能强大，但也相对较复杂，所以就出现了第三方的开源工具封装”git-filter-branch”并提供简单易用的接口，<a href="https://rtyley.github.io/bfg-repo-cleaner">BFG Repo-Cleaner</a>就是其中比较出色的一个。仅管<a href="https://rtyley.github.io/bfg-repo-cleaner">BFG Repo-Cleaner</a>没有”git-filter-branch”的功能强大，但是它相对简洁、高效，并且基本上能满足日常大部分的需求。</p><h1 id="安装BFG-Repo-Cleaner"><a href="#安装BFG-Repo-Cleaner" class="headerlink" title="安装BFG Repo-Cleaner"></a>安装BFG Repo-Cleaner</h1><ul><li><p>从<a href="https://rtyley.github.io/bfg-repo-cleaner">官网</a>中下载BFG Repo-Cleaner(jar file)到某个路径下，并命名为bfg.jar</p></li><li><p>执行以下命令创建BFG Repo-Cleaner命令的别名，或者将下面的命令添加到shell的初始化文件中，以便自动添加这个命令的别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> bfg=<span class="hljs-string">&#x27;java -jar /xxxx/bfg.jar&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="使用BFG-Repo-Cleaner"><a href="#使用BFG-Repo-Cleaner" class="headerlink" title="使用BFG Repo-Cleaner"></a>使用BFG Repo-Cleaner</h1><p>BFG Repo-Cleaner主要有以下两种类型的应用：</p><ul><li>替换文件中的敏感信息</li><li>删除文件或文件夹</li></ul><p>可以执行命令获取BFG Repo-Cleaner的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>BFG Repo-Cleaner缺省不会清理最新版本代码里的脏数据，因为你的最新代码可能已经部署到生产环境，而且可能会依赖于这些已经存在的敏感信息或文件，所以你需要手动地清理这些敏感信息或文件并修复代码运行时可能存在的错误。如果你确认清理最新版本代码里的脏数据对代码运行不会产生影响，则可以在命令中显式地加上参数“–no-blob-protection”。</p><h2 id="替换文件中的敏感信息"><a href="#替换文件中的敏感信息" class="headerlink" title="替换文件中的敏感信息"></a>替换文件中的敏感信息</h2><p>这个操作主要是把文件中的敏感信息用指定的文本替换掉。比如文件中包含password&#x3D;123456，我们需要用文本”***hidden***“去替换”123456”。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>通过mirror的方式克隆代码仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --mirror https://github.com/xxxx/test-history-clean.git<br></code></pre></td></tr></table></figure></li><li><p>创建文本替换文件（例如replace-text.txt）<br>如果使用BFG缺省的替换文本”***REMOVED***“，文本替换文件中只需要列出需要替换的敏感信息的文本，一行一个，比如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">123456<br>89fsafaaf<br></code></pre></td></tr></table></figure><p>如果需要使用自定义的替换文本，文本替换文件的格式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">regex:xxxx==&gt;yyyy<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">glob:xxxx==&gt;yyyy<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">regex:123.*==&gt;***hidden***<br>regex:test123==&gt;***hidden***<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">glob:123*==&gt;***hidden***<br></code></pre></td></tr></table></figure><blockquote><p>Regex和Glob的区别可以参考<a href="https://www.linuxjournal.com/content/globbing-and-regex-so-similar-so-different">https://www.linuxjournal.com/content/globbing-and-regex-so-similar-so-different</a></p></blockquote></li></ul><h3 id="常用的敏感信息替换操作"><a href="#常用的敏感信息替换操作" class="headerlink" title="常用的敏感信息替换操作"></a>常用的敏感信息替换操作</h3><div class="note note-warning">            <p>在执行bfg命令前，请先确保最新代码里的敏感信息已经被替换（手工提交一个新的Git提交），否则在执行bfg命令时需要显式地加上参数“–no-blob-protection”以确保最新代码里的敏感信息也会被替换。</p>          </div><ul><li><p>替换所有文件中的指定的敏感信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -rt replace-text.txt test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><blockquote><p>需要打开强制推送到Git仓库的功能</p></blockquote></li><li><p>替换指定文件中的敏感信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -rt replace-text.txt -<span class="hljs-keyword">fi</span> test3.txt test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><blockquote><p>bfg不能指定具体文件的路径<br>-fi参数可以通过过glob语法指定某一类文件，比如*.{txt,properties}</p></blockquote></li><li><p>替换除了指定的文件外的所有文件中的敏感信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -rt replace-text.txt -fe test3.txt test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><blockquote><p>bfg不能指定具体文件的路径<br>-fe参数可以通过过glob语法指定某一类文件，比如*.{txt,properties}</p></blockquote></li></ul><h2 id="删除文件或文件夹"><a href="#删除文件或文件夹" class="headerlink" title="删除文件或文件夹"></a>删除文件或文件夹</h2><p>如果Git仓库中不小心提交了比较大的文件，或者整个文件夹，可以通过下面的操作从变更历史中把他们清理掉。</p><div class="note note-warning">            <p>在执行bfg命令前，请先确保最新代码里的文件或文件夹已经被删除（手工提交一个新的Git提交），否则在执行bfg命令时需要显式地加上参数“–no-blob-protection”以确保最新代码里的文件或文件夹也会被删除。</p>          </div><h3 id="删除文件名为“test3-tar-gz”的文件"><a href="#删除文件名为“test3-tar-gz”的文件" class="headerlink" title="删除文件名为“test3.tar.gz”的文件"></a>删除文件名为“test3.tar.gz”的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -D test3.tar.gz test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><h3 id="删除某一类文件"><a href="#删除某一类文件" class="headerlink" title="删除某一类文件"></a>删除某一类文件</h3><p>BFG Repo-Cleaner的-D参数可以通过glob格式指定某一类型的文件，例如删除后缀为dll或bin的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -D *&#123;dll,bin&#125; test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><h3 id="从变更历史中精确地删除某个文件"><a href="#从变更历史中精确地删除某个文件" class="headerlink" title="从变更历史中精确地删除某个文件"></a>从变更历史中精确地删除某个文件</h3><p>BFG Repo-Cleaner可以删除某个blob（git仓库的变更历史中存储的文件称为blob），而参数-bi(–strip-blobs-with-ids)可以用来指定待删除的blob id号。</p><ul><li>获取指定文件在所有变更历史中对应的blob id号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --all --pretty=format:%H -- a/b/c/test1.txt  | xargs -n 1 -I &#123;&#125; sh -c <span class="hljs-string">&quot;git ls-tree  &#123;&#125; a/b/c/test1.txt&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span> &gt; blob-ids.txt<br></code></pre></td></tr></table></figure><ul><li>从变更历史中删除指定的文件(Blob)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -bi blob-ids.txt test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><h3 id="删除超过某个大小的文件"><a href="#删除超过某个大小的文件" class="headerlink" title="删除超过某个大小的文件"></a>删除超过某个大小的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -b 500M test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><h3 id="删除前几个最大的文件"><a href="#删除前几个最大的文件" class="headerlink" title="删除前几个最大的文件"></a>删除前几个最大的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg -B 5 test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><h3 id="删除某个文件夹"><a href="#删除某个文件夹" class="headerlink" title="删除某个文件夹"></a>删除某个文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bfg --delete-folders .svn test-history-clean.git<br><span class="hljs-built_in">cd</span> test-history-clean.git<br>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br>git push --force<br></code></pre></td></tr></table></figure><blockquote><p>可以通过glob格式指定一类文件夹，例如*-tmp。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins构建GitLab合并请求(Merge Request)</title>
    <link href="/2020/03/09/jenkins-gitlab-pullrequest/"/>
    <url>/2020/03/09/jenkins-gitlab-pullrequest/</url>
    
    <content type="html"><![CDATA[<p>写了两篇这样的文章，我们大概可以总结出Jenkins构建合并请求(Merge Request)的原理：首先，需要在Jenkins上安装一个插件以便提供一个Webhook接口，配置插件连通对应的代码协作平台以便将构建状态写回代码协作平台(并不是所有的插件都提供这个功能)；其次，在对应的Git仓库中设置Webhook监听Git事件，比如合并请求(Merge Request)的创建、编辑等。当有监听的事件发生时，Webhook触发Jenkins的Webhook接口，Webhook接口解析请求数据，创建一些有用的环境变量，比如合并请求(Merge Request)ID，合并请求(Merge Request)的原分支和目标分支等，并触发对应的Jenkins pipeline；最后，创建一个Jenkins pipeline(目前主要是Pipeline2.0的Jenkinsfile)，设置被触发的条件和如何克隆对应的代码，以及实际的构建逻辑。接前面的系列，本文将继续介绍如何配置Jenkins和GitLab来构建GitLab合并请求(Merge Request)。</p><span id="more"></span><p>GitLab<a href="https://docs.gitlab.com/ee/integration/jenkins.html">官方文档</a>有写到用Jenkins去构建GitLab中的代码，但是用到了”Jenkins CI”这个项目服务，而这个服务在GitLab免费版本(社区版)中并没有提供，所以不去过多的讨论此方法。下面将利用Jenkins的<a href="https://plugins.jenkins.io/git/">Git插件</a>和<a href="https://plugins.jenkins.io/gitlab-plugin/">GitLab插件</a>去实现Jenkins构建GitLab的合并请求(Merge Request)。</p><h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="安装GitLab插件-如果Git插件不存在，会作为GitLab插件的依赖被安装"><a href="#安装GitLab插件-如果Git插件不存在，会作为GitLab插件的依赖被安装" class="headerlink" title="安装GitLab插件(如果Git插件不存在，会作为GitLab插件的依赖被安装)"></a>安装GitLab插件(如果Git插件不存在，会作为GitLab插件的依赖被安装)</h2><ol><li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins打开Plugin Manager页面</p></li><li><p>打开Available页面，选择GitLab插件，点击Install without restart按钮</p><p><img src="/2020/03/09/jenkins-gitlab-pullrequest/1.png"></p></li><li><p>必要时重启Jenkins让插件生效</p></li></ol><p>安装完插件后，生成的Web hook url地址为<code>https://JENKINS_URL/project/YOUR_JOB</code>。</p><h2 id="创建Gitlab-Personal-Access-Token"><a href="#创建Gitlab-Personal-Access-Token" class="headerlink" title="创建Gitlab Personal Access Token"></a>创建Gitlab Personal Access Token</h2><ol><li><p>点击Settings打开用户设置页面，并点击Access Tokens打开创建Personal Access Token页面</p><p><img src="/2020/03/09/jenkins-gitlab-pullrequest/3.png"></p></li><li><p>在Name字段填上Token的名字，在Scope字段选上需要的权限，api的权限应该足够了。如果需要设置有效期限，可以设置Expires at字段，否则Token永不过期</p></li><li><p>点击Create personal access token按钮创建Token。注意，需要立即复制这个Token值，否则页面刷新后就会被隐藏掉</p></li></ol><h2 id="配置Jenkins-Gitlab插件"><a href="#配置Jenkins-Gitlab插件" class="headerlink" title="配置Jenkins Gitlab插件"></a>配置Jenkins Gitlab插件</h2><ol><li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Config System打开系统配置页面</p></li><li><p>定位到”GitLab“段落，点击Add菜单打开创建Jenkins认证信息对话框<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/2.png"></p></li><li><p>选择”GitLab API Token”类型的凭证，在API token字段里输入前面创建的Gitlab Personal Access Token，设置Token的ID和描述<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/4.png"></p></li><li><p>设置Gitlab详细的连接信息<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/5.png"></p><p>设置Connection name，Gitlab host URL，选择刚刚创建的GitLab API Token，连接和读取超时可以稍微设大一点。可以点击Test Connection测试是否能连通。</p></li><li><p>点击”Save”按钮保存配置</p></li></ol><h1 id="创建Jenkins-pipeline-job用来构建合并请求-Merge-Request"><a href="#创建Jenkins-pipeline-job用来构建合并请求-Merge-Request" class="headerlink" title="创建Jenkins pipeline job用来构建合并请求(Merge Request)"></a>创建Jenkins pipeline job用来构建合并请求(Merge Request)</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent &#123;<br>        label <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;<br>    triggers &#123;<br>        gitlab(<br>            <span class="hljs-symbol">triggerOnPush:</span> <span class="hljs-literal">false</span>,<br>            <span class="hljs-symbol">triggerOnMergeRequest:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">triggerOpenMergeRequestOnPush:</span> <span class="hljs-string">&quot;source&quot;</span>,<br>            <span class="hljs-symbol">triggerOnNoteRequest:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">noteRegex:</span> <span class="hljs-string">&quot;.*\\[run\\W+ci\\].*&quot;</span>,<br>            <span class="hljs-symbol">skipWorkInProgressMergeRequest:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">ciSkip:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">setBuildDescription:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">addNoteOnMergeRequest:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">addCiMessage:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">addVoteOnMergeRequest:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-symbol">acceptMergeRequestOnSuccess:</span> <span class="hljs-literal">false</span>,<br>            <span class="hljs-symbol">branchFilterType:</span> <span class="hljs-string">&quot;NameBasedFilter&quot;</span>,<br>            <span class="hljs-symbol">includeBranchesSpec:</span> <span class="hljs-string">&quot;master&quot;</span>,<br>            <span class="hljs-symbol">excludeBranchesSpec:</span> <span class="hljs-string">&quot;&quot;</span><br>        )<br>    &#125;<br>    environment &#123;<br>        GITLAB_URL = <span class="hljs-string">&quot;http://mygitlab.philips.com&quot;</span><br>        GITLAB_ORG = <span class="hljs-string">&quot;mikesay&quot;</span><br>        GITLAB_REPO = <span class="hljs-string">&quot;mikesay-test-1&quot;</span><br>    &#125;<br>    options &#123;<br>        skipDefaultCheckout()<br>        ansiColor(<span class="hljs-string">&#x27;xterm&#x27;</span>)<br>        gitLabConnection <span class="hljs-string">&#x27;mygitlab&#x27;</span><br>    &#125;<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;Checkout&#x27;</span>) &#123;<br>            steps &#123;<br>                script&#123;<br>                    <span class="hljs-keyword">def</span> scmVars =   checkout(<br>                                        [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;GitSCM&#x27;</span>, <span class="hljs-attr">branches:</span> [[<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;origin/mr/$&#123;gitlabMergeRequestId&#125;/head&quot;</span>]], <br>                                        <span class="hljs-symbol">doGenerateSubmoduleConfigurations:</span> <span class="hljs-literal">false</span>,<br>                                        <span class="hljs-symbol">submoduleCfg:</span> [], <br>                                        <span class="hljs-symbol">extensions:</span> [<br>                                            [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;RelativeTargetDirectory&#x27;</span>, <span class="hljs-attr">relativeTargetDir:</span> <span class="hljs-string">&#x27;codes&#x27;</span>],<br>                                            [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;CleanBeforeCheckout&#x27;</span>]<br>                                        ],<br>                                        <span class="hljs-symbol">userRemoteConfigs:</span> [<br>                                                [<br>                                                    <span class="hljs-symbol">credentialsId:</span> <span class="hljs-string">&#x27;gitlab_account&#x27;</span>, <br>                                                    <span class="hljs-symbol">name:</span> <span class="hljs-string">&#x27;origin&#x27;</span>, <br>                                                    <span class="hljs-symbol">refspec:</span> <span class="hljs-string">&#x27;+refs/heads/*:refs/remotes/origin/* +refs/merge-requests/*:refs/remotes/origin/mr/*&#x27;</span>, <br>                                                    <span class="hljs-symbol">url:</span> <span class="hljs-string">&quot;$&#123;GITLAB_URL&#125;/$&#123;GITLAB_ORG&#125;/$&#123;GITLAB_REPO&#125;.git&quot;</span><br>                                                ]<br>                                            ]<br>                                        ]<br>                                    )<br>                    env.GIT_BRANCH = <span class="hljs-string">&quot;$&#123;scmVars.GIT_BRANCH&#125;&quot;</span><br>                    env.GIT_COMMIT = <span class="hljs-string">&quot;$&#123;scmVars.GIT_COMMIT&#125;&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;<br>            steps &#123;<br>                dir(<span class="hljs-string">&#x27;codes&#x27;</span>) &#123;<br>                    sh <span class="hljs-string">&#x27;&#x27;&#x27;#!/bin/bash -l</span><br><span class="hljs-string">                        echo &quot;Start building!&quot;</span><br><span class="hljs-string">                    &#x27;&#x27;&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    post &#123;<br>      failure &#123;<br>        updateGitlabCommitStatus <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;build&#x27;</span>, <span class="hljs-attr">state:</span> <span class="hljs-string">&#x27;failed&#x27;</span><br>      &#125;<br>      success &#123;<br>        updateGitlabCommitStatus <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;build&#x27;</span>, <span class="hljs-attr">state:</span> <span class="hljs-string">&#x27;success&#x27;</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>6行-22行设置GitLab触发器，主要设置如下：</p><table><thead><tr><th>变量</th><th>事例值</th></tr></thead><tbody><tr><td>triggerOnPush</td><td>任何推送事件都会触发构建。因为是用来构建合并请求(Merge Request)，只需要监听合并请求(Merge Request)事件，所以不需要打开。</td></tr><tr><td>triggerOnMergeRequest</td><td>设置合并请求(Merge Request)事件触发构建，需要打开。</td></tr><tr><td>triggerOpenMergeRequestOnPush</td><td>当合并请求(Merge Request)的原分支有新的推送触发构建，需要打开。</td></tr><tr><td>triggerOnNoteRequest</td><td>合并请求(Merge Request)的评论有更新时触发构建，需要打开，并且配合noteRegex设置具体的触发构建的字符串。</td></tr><tr><td>ciSkip</td><td>当合并请求(Merge Request)的评论包括字符串”[ci-skip]”时，不会构建这个合并请求(Merge Request)。</td></tr><tr><td>branchFilterType, includeBranchesSpec, excludeBranchesSpec</td><td>设置哪些分支上的合并请求(Merge Request)会触发构建。</td></tr></tbody></table></li><li><p>50行: 添加refspec获取合并请求(merge request)的分支信息</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">refspec:</span> <span class="hljs-string">&#x27;+refs/merge-requests/*:refs/remotes/origin/mr/*&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>39行: branches选择”origin&#x2F;mr&#x2F;${gitlabMergeRequestId}&#x2F;head”, 是合并后的分支。环境变量”gitlabMergeRequestId”是合并请求(merge request)的ID号</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">[<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;GitSCM&#x27;</span>, <span class="hljs-attr">branches:</span> [[<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;origin/mr/$&#123;gitlabMergeRequestId&#125;/head&quot;</span>]]<br></code></pre></td></tr></table></figure></li></ol><p>除了”gitlabMergeRequestId”外，Gitlab插件还往当前构建中注入了许多变量供构建Job使用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy">gitlabBranch<br>gitlabSourceBranch<br>gitlabActionType<br>gitlabUserName<br>gitlabUserUsername<br>gitlabUserEmail<br>gitlabSourceRepoHomepage<br>gitlabSourceRepoName<br>gitlabSourceNamespace<br>gitlabSourceRepoURL<br>gitlabSourceRepoSshUrl<br>gitlabSourceRepoHttpUrl<br>gitlabMergeRequestTitle<br>gitlabMergeRequestDescription<br>gitlabMergeRequestId<br>gitlabMergeRequestIid<br>gitlabMergeRequestState<br>gitlabMergedByUser<br>gitlabMergeRequestAssignee<br>gitlabMergeRequestLastCommit<br>gitlabMergeRequestTargetProjectId<br>gitlabTargetBranch<br>gitlabTargetRepoName<br>gitlabTargetNamespace<br>gitlabTargetRepoSshUrl<br>gitlabTargetRepoHttpUrl<br>gitlabBefore<br>gitlabAfter<br>gitlabTriggerPhrase<br></code></pre></td></tr></table></figure><h2 id="创建Jenkins-job引用Jenkinsfile"><a href="#创建Jenkins-job引用Jenkinsfile" class="headerlink" title="创建Jenkins job引用Jenkinsfile"></a>创建Jenkins job引用Jenkinsfile</h2><ol><li><p>点击”New Item”</p></li><li><p>选择Job类型为”Pipeline”，输入Job的名字，比如”gitlab-preflight”，点击”Ok”按钮<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/6.png"></p></li><li><p>在”Pipeline”段，引用Jenkinsfile(Jenkinsfile是单独放在一个独立的Git仓库中的)<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/7.png"></p></li><li><p>点击”Save”按钮保存Jenkins Job</p></li><li><p>手动触发Job一次让Jenkinsfile中设置的触发规则配置到job中。<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/8.png"></p></li></ol><h1 id="配置Gitlab"><a href="#配置Gitlab" class="headerlink" title="配置Gitlab"></a>配置Gitlab</h1><h2 id="创建Jenkins-API-token"><a href="#创建Jenkins-API-token" class="headerlink" title="创建Jenkins API token"></a>创建Jenkins API token</h2><ol><li><p>进入Jenkins用户设置页面<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/11.png"></p></li><li><p>点击Add new Token，并点击Generate按钮产生当前用户的API Token，注意立即复制保存，因为页面刷新后，将被隐藏<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/12.png"></p></li><li><p>点击Save按钮保存</p></li></ol><h2 id="创建Gitlab-Web-hook"><a href="#创建Gitlab-Web-hook" class="headerlink" title="创建Gitlab Web hook"></a>创建Gitlab Web hook</h2><ol><li><p>进入具体的项目页面，点击Settings -&gt; Integrations打开创建Web hook的页面<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/13.png"></p></li><li><p>设置Web hook详细信息<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/14.png"></p></li></ol><p>在URL地址里输入Jenkins Gitlab插件生成的Web hook地址，包括Jenkins的认证信息，比如<code>https://&lt;jenkins user&gt;:&lt;user&#39;s api token&gt;@mykube.com/jenkins/project/gitlab-preflight</code>，选择”Comments”和”Merge request events”用来监听合并请求(merge request)事件，包括评论更新事件。</p><ol start="3"><li>点击Add webhook按钮添加Web hook</li></ol><h1 id="创建合并请求-merge-request-触发构建"><a href="#创建合并请求-merge-request-触发构建" class="headerlink" title="创建合并请求(merge request)触发构建"></a>创建合并请求(merge request)触发构建</h1><ol><li><p>Gitlab的合并请求(merge request)<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/9.png"></p></li><li><p>触发的构建<br><img src="/2020/03/09/jenkins-gitlab-pullrequest/10.png"></p></li></ol><p>从构建的描述来看，Jenkins Gitlab插件提供了比较全面的功能，显示了合并请求(merge request)的信息，同时在Gitlab的合并请求(merge request)页面也显示了构建的信息。</p>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Git</tag>
      
      <tag>Jenkins</tag>
      
      <tag>GitLab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins构建Bitbucket合并请求(Pull Request)</title>
    <link href="/2020/02/23/jenkins-bibucket-pullrequest/"/>
    <url>/2020/02/23/jenkins-bibucket-pullrequest/</url>
    
    <content type="html"><![CDATA[<p>在<a href="http://www.mikesay.com/2020/01/30/jenkins-github-pullrequest/">“Jenkins随笔(3)  Jenkins构建Github合并请求(Pull Request)”</a>中介绍了用Jenkins构建Github合并请求(Pull Request)的方法以及preflight流水线的意义。本文将继续介绍如何配置Jenkins和Bitbucket来构建Bitbucket合并请求(Pull Request)。</p><span id="more"></span><p>Bitbucket官网提供了以下两种方法来配置Jenkins构建Bitbucket合并请求(Pull Request):</p><ol><li>Jenkins <a href="https://plugins.jenkins.io/git/">Git插件</a>结合Bitbucket插件<a href="https://marketplace.atlassian.com/apps/1211284/webhook-to-jenkins-for-bitbucket/version-history">Webhook to Jenkins for Bitbucket</a></li><li>Jenkins <a href="https://plugins.jenkins.io/cloudbees-bitbucket-branch-source/">Bitbucket Branch Source</a>插件</li></ol><p>方法1中的Bitbucket插件Webhook to Jenkins for Bitbucket是商业版的，需要收费，个人觉得不值得，也没有尝试。方法2中的Jenkins Bitbucket Branch Source插件适合于Jenkins多分支流水线， 也不是本文讨论的范围。除此之外，Jenkins还有这三个插件可用：</p><ul><li>Jenkins <a href="https://plugins.jenkins.io/bitbucket-pullrequest-builder/">Bitbucket Pullrequest Builder</a>插件</li><li>Jenkins <a href="https://plugins.jenkins.io/bitbucket/">Bitbucket</a>插件</li><li>Jenkins <a href="https://plugins.jenkins.io/bitbucket-push-and-pull-request/">Bitbucket Push and Pull Request</a>插件</li></ul><p>Bitbucket Pullrequest Builder插件有一些严重的问题<a href="https://plugins.jenkins.io/bitbucket-pullrequest-builder/">(https://plugins.jenkins.io/bitbucket-pullrequest-builder/)</a>，所以不能采用。Bitbucket插件是目前网上大部分文章讨论用到的插件，但是测试下来发现个问题，即提交代码到现有的合并请求(Pull Request)不会触发新的合并请求(Pull Request)的构建，这个问题首先是Bitbucket Webhook并没有提供一个这样的事件(<a href="https://community.atlassian.com/t5/Bitbucket-questions/How-to-trigger-a-webhook-when-a-commit-is-pushed-to-an-open-pull/qaq-p/1029556">网上也有类似的讨论</a>)，其次Bitbucket插件也没有提供足够的灵活性方便解决它。最终测试下来觉得Bitbucket Push and Pull Request插件可以使用，首先它是从Bitbucket插件继承过来的，包含了Bitbucket插件的所有功能，其次通过使用Bitbucket Push and Pull Request插件，可以配置一个临时的方法解决我们发现的Bitbucket插件和Bitbucket Webhook的问题。下面将详细介绍利用Jenkins Bitbucket Push and Pull Request插件来构建Bitbucket合并请求(Pull Request)。</p><h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="安装Bitbucket-Push-and-Pull-Request插件"><a href="#安装Bitbucket-Push-and-Pull-Request插件" class="headerlink" title="安装Bitbucket Push and Pull Request插件"></a>安装Bitbucket Push and Pull Request插件</h2><ol><li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins打开Plugin Manager页面</p></li><li><p>打开Available页面，选择Github Pull Request Builder，点击Install without restart按钮<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/1.png"></p></li><li><p>必要时重启Jenkins让插件生效</p></li></ol><p>安装完插件后，生成的Web hook url地址为<code>http://&lt;jenkins url&gt;/bitbucket-hook/</code>。</p><h1 id="配置Bitbucket代码仓库"><a href="#配置Bitbucket代码仓库" class="headerlink" title="配置Bitbucket代码仓库"></a>配置Bitbucket代码仓库</h1><ol><li><p>点击”Repository settings” -&gt; “Webhooks”打开Webhooks创建页面<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/2.png"></p></li><li><p>点击”Create webhook”按钮打开添加Webhook页面<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/3.png"></p></li></ol><p>添加以下的信息后点击保存按钮创建新的Webhook:</p><ul><li>URL: 设置为Bitbucket Push and Pull Request插件生成的Web hook url地址：<code>http://&lt;jenkins url&gt;/bitbucket-hook/</code></li><li>Pull request事件: 选择”Opened”和”Modified”</li><li>Repository事件: 选择”Push”<blockquote><p>这里选择Push事件是为了解决文章开头提到的Bitbucket插件和Bitbucket Webhook的问题，即提交代码到已有的合并请求(Pull Request)不会触发新的合并请求(Pull Request)的构建。</p></blockquote></li></ul><h1 id="创建Jenkins-pipeline-job用来构建合并请求-pull-x2F-merge-request"><a href="#创建Jenkins-pipeline-job用来构建合并请求-pull-x2F-merge-request" class="headerlink" title="创建Jenkins pipeline job用来构建合并请求(pull&#x2F;merge request)"></a>创建Jenkins pipeline job用来构建合并请求(pull&#x2F;merge request)</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent &#123;<br>        label <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;<br>    triggers &#123;<br>        bitBucketTrigger(<br>            [<br>                [<br>                    <span class="hljs-symbol">$class:</span> <span class="hljs-string">&#x27;BitBucketPPRPullRequestServerTriggerFilter&#x27;</span>,<br>                    <span class="hljs-symbol">actionFilter:</span> [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;BitBucketPPRPullRequestServerCreatedActionFilter&#x27;</span>, <span class="hljs-attr">allowedBranches:</span> <span class="hljs-string">&#x27;&#x27;</span>]<br>                ], <br>                [<br>                    <span class="hljs-symbol">$class:</span> <span class="hljs-string">&#x27;BitBucketPPRPullRequestServerTriggerFilter&#x27;</span>, <br>                    <span class="hljs-symbol">actionFilter:</span> [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;BitBucketPPRPullRequestServerUpdatedActionFilter&#x27;</span>, <span class="hljs-attr">allowedBranches:</span> <span class="hljs-string">&#x27;&#x27;</span>]<br>                ],<br>                [<br>                    <span class="hljs-symbol">$class:</span> <span class="hljs-string">&#x27;BitBucketPPRRepositoryTriggerFilter&#x27;</span>, <br>                    <span class="hljs-symbol">actionFilter:</span> [<br>                                    <span class="hljs-symbol">$class:</span> <span class="hljs-string">&#x27;BitBucketPPRServerRepositoryPushActionFilter&#x27;</span>, <br>                                    <span class="hljs-symbol">allowedBranches:</span> <span class="hljs-string">&#x27;&#x27;</span>, <br>                                    <span class="hljs-symbol">triggerAlsoIfNothingChanged:</span> <span class="hljs-literal">true</span>, <br>                                    <span class="hljs-symbol">triggerAlsoIfTagPush:</span> <span class="hljs-literal">false</span><br>                                ]<br>                ]<br>            ]<br>        )<br>    &#125;<br>    environment &#123;<br>        BITBUCKET_URL = <span class="hljs-string">&quot;http://130.147.249.221:7990&quot;</span><br>        BITBUCKET_ORG = <span class="hljs-string">&quot;miks&quot;</span><br>        BITBUCKET_REPO = <span class="hljs-string">&quot;mikesay-test-1&quot;</span><br>    &#125;<br>    options &#123;<br>        skipDefaultCheckout()<br>        ansiColor(<span class="hljs-string">&#x27;xterm&#x27;</span>)<br>    &#125;<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;Checkout&#x27;</span>) &#123;<br>            steps &#123;<br>                script&#123;<br>                    <span class="hljs-keyword">def</span> scmVars =   checkout(<br>                                        [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;GitSCM&#x27;</span>, <span class="hljs-attr">branches:</span> [[<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;origin/pr/*/merge&quot;</span>]], <br>                                        <span class="hljs-symbol">doGenerateSubmoduleConfigurations:</span> <span class="hljs-literal">false</span>,<br>                                        <span class="hljs-symbol">submoduleCfg:</span> [], <br>                                        <span class="hljs-symbol">extensions:</span> [<br>                                            [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;RelativeTargetDirectory&#x27;</span>, <span class="hljs-attr">relativeTargetDir:</span> <span class="hljs-string">&#x27;codes&#x27;</span>],<br>                                            [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;CleanBeforeCheckout&#x27;</span>]<br>                                        ],<br>                                        <span class="hljs-symbol">userRemoteConfigs:</span> [<br>                                                [<br>                                                    <span class="hljs-symbol">credentialsId:</span> <span class="hljs-string">&#x27;ghe_account&#x27;</span>, <br>                                                    <span class="hljs-symbol">name:</span> <span class="hljs-string">&#x27;origin&#x27;</span>, <br>                                                    <span class="hljs-symbol">refspec:</span> <span class="hljs-string">&#x27;+refs/pull-requests/*:refs/remotes/origin/pr/*&#x27;</span>, <br>                                                    <span class="hljs-symbol">url:</span> <span class="hljs-string">&quot;$&#123;BITBUCKET_URL&#125;/scm/$&#123;BITBUCKET_ORG&#125;/$&#123;BITBUCKET_REPO&#125;.git&quot;</span><br>                                                ]<br>                                            ]<br>                                        ]<br>                                    )<br>                    env.GIT_BRANCH = <span class="hljs-string">&quot;$&#123;scmVars.GIT_BRANCH&#125;&quot;</span><br>                    env.GIT_COMMIT = <span class="hljs-string">&quot;$&#123;scmVars.GIT_COMMIT&#125;&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;<br>            steps &#123;<br>                dir(<span class="hljs-string">&#x27;codes&#x27;</span>) &#123;<br>                    sh <span class="hljs-string">&#x27;&#x27;&#x27;#!/bin/bash -l</span><br><span class="hljs-string">                        echo &quot;Start building!&quot;</span><br><span class="hljs-string">                    &#x27;&#x27;&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>8行-24行: 配置Job触发事件，分别是合并请求(Pull Request)的创建(Create)，更新(Update)事件，以及Git仓库的推送(Push)事件，同时设置”triggerAlsoIfNothingChanged”的值为true。勾选Git仓库的推送(Push)事件和设置”triggerAlsoIfNothingChanged”的值为true是为了过滤前面Webhook中设置的Git仓库的推送(Push)事件，这样当有新的提交推送到合并请求(Pull Request)后，Job也能被触发。</p><p>53行：设置拉取合并请求(Pull Request)的配置。可以参考之前的文章<a href="http://www.mikesay.com/2020/01/29/pullrequest-essential/">“Git随笔(1) Git合并请求(pull&#x2F;merge request)的本质”</a>。</p><p>42行：构建分支设置为<code>origin/pr/*/merge</code>，这样可以构建所有合并请求(Pull Request)对应的分支。Bitbucket Push and Pull Request插件在触发构建时会传递一个环境变量”BITBUCKET_PULL_REQUEST_ID”到构建Job中，这个环境变量的值就是合并请求(Pull Request)的ID号。利用这个环境变量可以将构建分支设置的更精确一点，比如<code>origin/pr/$&#123;BITBUCKET_PULL_REQUEST_ID&#125;/merge</code>，但只有合并请求(Pull Request)的创建，关闭和重新打开的事件触发的构建Job才会传递这个变量，所以不怎么通用。</p><blockquote><p>将构建分支设置为通用的合并请求(Pull Request)分支也带来了个缺陷，就是当构建Job创建好后，必须手动触发多次以获取所有未完成的合并请求(Pull Request)分支的信息以便后续合并请求(Pull Request)有更新时，能够触发正确的构建。</p></blockquote><h2 id="创建Jenkins-job引用Jenkinsfile"><a href="#创建Jenkins-job引用Jenkinsfile" class="headerlink" title="创建Jenkins job引用Jenkinsfile"></a>创建Jenkins job引用Jenkinsfile</h2><ol><li><p>点击”New Item”</p></li><li><p>选择Job类型为”Pipeline”，输入Job的名字，比如”bitbucket-preflight”，点击”Ok”按钮<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/4.png"></p></li><li><p>在”Pipeline”段，引用Jenkinsfile(Jenkinsfile是单独放在一个独立的Git仓库中的)<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/5.png"></p></li><li><p>点击”Save”按钮保存Jenkins Job</p></li><li><p>手动触发Jenkins Job多次以获取所有未完成的合并请求(Pull Request)分支的信息。如果目前没有未完成的合并请求(Pull Request)，也需要手动触发Job一次让Jenkinsfile中设置的触发规则配置到job中。<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/6.png"></p></li></ol><h1 id="创建合并请求-pull-x2F-merge-request-触发构建"><a href="#创建合并请求-pull-x2F-merge-request-触发构建" class="headerlink" title="创建合并请求(pull&#x2F;merge request)触发构建"></a>创建合并请求(pull&#x2F;merge request)触发构建</h1><ol><li><p>Bitbucket的合并请求(pull&#x2F;merge request)<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/7.png"></p></li><li><p>触发的构建<br><img src="/2020/02/23/jenkins-bibucket-pullrequest/8.png"></p></li></ol><p>细心的读者可能发现，和Github合并请求(Pull Request)的构建相比少了很多有用的信息，比如构建描述中没有显示合并请求(Pull Request)号，不太容易知道当前的构建是由哪个合并请求(Pull Request)触发的，而在合并请求(Pull Request)的页面中也看不到当前构建的状态。这些都是由Jenkins插件提供的功能多少决定的，对于Bitbucket合并请求(Pull Request)的构建，我们需要更多的自定义工作以提供足够多的信息，比如从当前构建中获取合并请求(Pull Request)分支，提取出合并请求(Pull Request)号并且设置到构建描述中。</p>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Git</tag>
      
      <tag>Jenkins</tag>
      
      <tag>Bitbucket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令方式设置Windows Server网络代理</title>
    <link href="/2020/02/03/windows-core-proxy/"/>
    <url>/2020/02/03/windows-core-proxy/</url>
    
    <content type="html"><![CDATA[<p>在公司里的服务器往往需要配置网络代理才能访问外网，不同的操作系统设置代理的方式也不同，同一个操作系统在图形化和非图形化下的设置方式也不同。本文将详细介绍如何用命令的方式来设置Windows Server的网络代理，这种方式非常适合于非图形化的Windows Server Core的网络代理的设置，对图形化的Windows Server也同样适用。</p><span id="more"></span><h1 id="Windows-Server网络代理说明"><a href="#Windows-Server网络代理说明" class="headerlink" title="Windows Server网络代理说明"></a>Windows Server网络代理说明</h1><p>在图形化的Windows Server中设置网络代理相对来说比较简单，通常在IE浏览器的”Internet Options”里面设置即可：<br><img src="/2020/02/03/windows-core-proxy/1.png"></p><p>但是这个网络代理只对一部分应用起作用，比如IE浏览器等。仍旧有些应用不是使用这个网络代理。在Windows Server环境中，有以下四类网络使用方式：</p><ul><li><p>使用WinINET库<br>WinINTE是IE浏览器的核心，同时也能被别的应用程序使用。使用WinINET的应用同样会使用IE浏览器的网络代理设置。</p></li><li><p>使用WinHTTP库<br>WinHTTP主要是被Windows中非交互式的应用所使用，比如需要访问网络的Windows服务或后台任务等。WinHTTP缺省不使用WinINET的网络代理设置。</p></li><li><p>Linux风格的网络代理<br>许多Linux用户在使用Windows时仍然希望使用Linux相关的命令，他们往往通过安装<a href="https://www.cygwin.com/">Cygwin</a>，或者<a href="http://getgnuwin32.sourceforge.net/">GunWin32</a>来引入Linux命令，而涉及到网络操作的命令则是通过Linux风格的网络代理来访问网络。Linux系统一般是以非图形化的方式作为服务器，所以其网络代理设置通常只需要设置环境变量：https_proxy, http_proxy和no_proxy，而桌面版的Linux是带有图形化的，其网络设置除了三个环境变量外，还需要其它地方的设置，否则那些图形化的应用将无法访问网络。本文将只介绍非图形化的Linux网络代理设置。</p></li><li><p>应用级别的网络代理设置<br>有些应用本身支持设置自己的网络代理，而不依赖于系统设置的代理。这些应用本身会实现很多底层的操作，比如直接使用Winsock建立网络连接。</p></li></ul><p>接下来将详细介绍WinINET，WinHTTP和Linux风格的网络代理设置。</p><h1 id="设置WinINET类型的网络代理"><a href="#设置WinINET类型的网络代理" class="headerlink" title="设置WinINET类型的网络代理"></a>设置WinINET类型的网络代理</h1><h2 id="设置自动代理脚本"><a href="#设置自动代理脚本" class="headerlink" title="设置自动代理脚本"></a>设置自动代理脚本</h2><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ps"><span class="hljs-variable">$proxyScript</span> = <span class="hljs-string">&quot;http://&lt;your url&gt;/proxy.pac&quot;</span><br><span class="hljs-variable">$regs</span> = <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span>,<span class="hljs-string">&quot;HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$reg</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$regs</span>)&#123;<br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> AutoConfigURL <span class="hljs-literal">-Value</span> <span class="hljs-variable">$proxyScript</span><br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyEnable <span class="hljs-literal">-Value</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="设置手动代理"><a href="#设置手动代理" class="headerlink" title="设置手动代理"></a>设置手动代理</h2><p>参考:<br><a href="https://config9.com/windows/powershell/using-powershell-to-programmatically-configure-internet-explorer-proxy-settings-to-work-before-it-has-been-opened/">https://config9.com/windows/powershell/using-powershell-to-programmatically-configure-internet-explorer-proxy-settings-to-work-before-it-has-been-opened/</a></p><h3 id="系统级别的设置"><a href="#系统级别的设置" class="headerlink" title="系统级别的设置"></a>系统级别的设置</h3><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ps"><span class="hljs-variable">$proxy</span>=<span class="hljs-string">&quot;http=&lt;server&gt;:&lt;port&gt;;https=&lt;server&gt;:&lt;port&gt;;ftp=&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-variable">$bypassList</span>=<span class="hljs-string">&quot;&lt;local&gt;;*.xxxx.com;xxxx.com;192.168.56.*;10.0.0.*&quot;</span><br><br><span class="hljs-variable">$proxyString</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>;<span class="hljs-variable">$i</span> <span class="hljs-operator">-lt</span> (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$proxy</span>)).length); <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$i</span> % <span class="hljs-number">2</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable">$byte</span> = (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$proxy</span>))[<span class="hljs-variable">$i</span>])<br>        <span class="hljs-variable">$convertedByte</span>=%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$byte</span>,<span class="hljs-number">16</span>)&#125;<br>        <span class="hljs-variable">$proxyString</span> = <span class="hljs-variable">$proxystring</span> + <span class="hljs-variable">$convertedByte</span>  + <span class="hljs-string">&quot;,&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">$bypassString</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>;<span class="hljs-variable">$i</span> <span class="hljs-operator">-lt</span> (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$bypassList</span>)).length); <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$i</span> % <span class="hljs-number">2</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable">$byte</span> = (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$bypassList</span>))[<span class="hljs-variable">$i</span>])<br>        <span class="hljs-variable">$convertedByte</span>=%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$byte</span>,<span class="hljs-number">16</span>)&#125;<br>        <span class="hljs-variable">$bypassString</span> = <span class="hljs-variable">$bypassString</span> + <span class="hljs-variable">$convertedByte</span>  + <span class="hljs-string">&quot;,&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">$regString</span>=<span class="hljs-string">&quot;46,00,00,00,00,00,00,00,0b,00,00,00,&quot;</span>+(%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$proxy</span>.length,<span class="hljs-number">16</span>)&#125;)+<span class="hljs-string">&quot;,00,00,00,&quot;</span> + <span class="hljs-variable">$proxystring</span> + (%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$bypassList</span>.length,<span class="hljs-number">16</span>)&#125;) + <span class="hljs-string">&quot;,00,00,00,&quot;</span> + <span class="hljs-variable">$bypassString</span> +  <span class="hljs-string">&quot;00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00&quot;</span><br><span class="hljs-variable">$regstringAsArray</span> = (<span class="hljs-string">&quot;0x&quot;</span>+<span class="hljs-variable">$regString</span>.replace(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;,0x&quot;</span>)).Split(<span class="hljs-string">&quot;,&quot;</span>)<br><br><span class="hljs-variable">$reg</span> = <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxySettingsPerUser <span class="hljs-literal">-Value</span> <span class="hljs-number">0</span><br><br><span class="hljs-variable">$regs</span> = <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span>,<span class="hljs-string">&quot;HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$reg</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$regs</span>)&#123;<br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyServer <span class="hljs-literal">-Value</span> <span class="hljs-variable">$proxy</span><br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyEnable <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyOverride <span class="hljs-literal">-Value</span> <span class="hljs-variable">$bypassList</span><br>&#125;<br><br><span class="hljs-variable">$regs</span> = <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections&quot;</span>,<span class="hljs-string">&quot;HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings\Connections&quot;</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$reg</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$regs</span>)&#123;<br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> DefaultConnectionSettings <span class="hljs-literal">-Type</span> Binary <span class="hljs-literal">-Value</span> <span class="hljs-variable">$regstringAsArray</span><br>    <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> SavedLegacySettings <span class="hljs-literal">-Type</span> Binary <span class="hljs-literal">-Value</span> <span class="hljs-variable">$regstringAsArray</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户级别的设置"><a href="#用户级别的设置" class="headerlink" title="用户级别的设置"></a>用户级别的设置</h3><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ps"><span class="hljs-variable">$proxy</span>=<span class="hljs-string">&quot;http=&lt;server&gt;:&lt;port&gt;;https=&lt;server&gt;:&lt;port&gt;;ftp=&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-variable">$bypassList</span>=<span class="hljs-string">&quot;&lt;local&gt;;*.xxxx.com;xxxx.com;192.168.56.*;10.0.0.*&quot;</span><br><br><span class="hljs-variable">$proxyString</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>;<span class="hljs-variable">$i</span> <span class="hljs-operator">-lt</span> (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$proxy</span>)).length); <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$i</span> % <span class="hljs-number">2</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable">$byte</span> = (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$proxy</span>))[<span class="hljs-variable">$i</span>])<br>        <span class="hljs-variable">$convertedByte</span>=%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$byte</span>,<span class="hljs-number">16</span>)&#125;<br>        <span class="hljs-variable">$proxyString</span> = <span class="hljs-variable">$proxystring</span> + <span class="hljs-variable">$convertedByte</span>  + <span class="hljs-string">&quot;,&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">$bypassString</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>;<span class="hljs-variable">$i</span> <span class="hljs-operator">-lt</span> (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$bypassList</span>)).length); <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$i</span> % <span class="hljs-number">2</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable">$byte</span> = (([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="hljs-variable">$bypassList</span>))[<span class="hljs-variable">$i</span>])<br>        <span class="hljs-variable">$convertedByte</span>=%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$byte</span>,<span class="hljs-number">16</span>)&#125;<br>        <span class="hljs-variable">$bypassString</span> = <span class="hljs-variable">$bypassString</span> + <span class="hljs-variable">$convertedByte</span>  + <span class="hljs-string">&quot;,&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">$regString</span>=<span class="hljs-string">&quot;46,00,00,00,00,00,00,00,0b,00,00,00,&quot;</span>+(%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$proxy</span>.length,<span class="hljs-number">16</span>)&#125;)+<span class="hljs-string">&quot;,00,00,00,&quot;</span> + <span class="hljs-variable">$proxystring</span> + (%&#123;[<span class="hljs-type">System.Convert</span>]::ToString(<span class="hljs-variable">$bypassList</span>.length,<span class="hljs-number">16</span>)&#125;) + <span class="hljs-string">&quot;,00,00,00,&quot;</span> + <span class="hljs-variable">$bypassString</span> +  <span class="hljs-string">&quot;00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00&quot;</span><br><span class="hljs-variable">$regstringAsArray</span> = (<span class="hljs-string">&quot;0x&quot;</span>+<span class="hljs-variable">$regString</span>.replace(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;,0x&quot;</span>)).Split(<span class="hljs-string">&quot;,&quot;</span>)<br><br><span class="hljs-variable">$reg</span> = <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxySettingsPerUser <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span><br><br><span class="hljs-variable">$reg</span> = <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyServer <span class="hljs-literal">-Value</span> <span class="hljs-variable">$proxy</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyEnable <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> ProxyOverride <span class="hljs-literal">-Value</span> <span class="hljs-variable">$bypassList</span><br><br><span class="hljs-variable">$reg</span> = <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections&quot;</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> DefaultConnectionSettings <span class="hljs-literal">-Type</span> Binary <span class="hljs-literal">-Value</span> <span class="hljs-variable">$regstringAsArray</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> SavedLegacySettings <span class="hljs-literal">-Type</span> Binary <span class="hljs-literal">-Value</span> <span class="hljs-variable">$regstringAsArray</span><br></code></pre></td></tr></table></figure><blockquote><p>Windows代理的忽略列表支持通配符*</p></blockquote><h1 id="设置WinHTTP类型的网络代理"><a href="#设置WinHTTP类型的网络代理" class="headerlink" title="设置WinHTTP类型的网络代理"></a>设置WinHTTP类型的网络代理</h1><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ps">netsh winhttp <span class="hljs-built_in">set</span> proxy proxy<span class="hljs-literal">-server</span>=<span class="hljs-string">&quot;http=&lt;server&gt;:&lt;port&gt;;https=&lt;server&gt;:&lt;port&gt;;ftp=&lt;server&gt;:&lt;port&gt;&quot;</span> bypass<span class="hljs-literal">-list</span>=<span class="hljs-string">&quot;&lt;local&gt;;*.xxxx.com;xxxx.com;192.168.56.*;10.0.0.*&quot;</span><br></code></pre></td></tr></table></figure><p>如果WinINET设置的是手动网络代理，也可以导入WinINET的网络代理：</p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ps">netsh winhttp import proxy ie<br></code></pre></td></tr></table></figure><h1 id="设置Linux风格的网络代理"><a href="#设置Linux风格的网络代理" class="headerlink" title="设置Linux风格的网络代理"></a>设置Linux风格的网络代理</h1><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ps"><span class="hljs-variable">$httpProxy</span> = <span class="hljs-string">&quot;http://&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-variable">$httpsProxy</span> = <span class="hljs-string">&quot;http://&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-variable">$noProxy</span> = <span class="hljs-string">&quot;localhost,127.0.0.1,.xxxx.com,xxxx.com,192.168.0.5&quot;</span><br><br><span class="hljs-variable">$reg</span> = <span class="hljs-string">&quot;HKLM:\SYSTEM\ControlSet001\Control\Session Manager\Environment&quot;</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> https_proxy <span class="hljs-literal">-Value</span> <span class="hljs-variable">$httpProxy</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> http_proxy <span class="hljs-literal">-Value</span> <span class="hljs-variable">$httpsProxy</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> no_proxy <span class="hljs-literal">-Value</span> <span class="hljs-variable">$noProxy</span><br><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> HTTPS_PROXY <span class="hljs-literal">-Value</span> <span class="hljs-variable">$httpProxy</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> HTTP_PROXY <span class="hljs-literal">-Value</span> <span class="hljs-variable">$httpsProxy</span><br><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$reg</span> <span class="hljs-literal">-Name</span> NO_PROXY <span class="hljs-literal">-Value</span> <span class="hljs-variable">$noProxy</span><br></code></pre></td></tr></table></figure><blockquote><p>Linux代理的忽略列表不支持通配符，比如*，但可以只增加域名后缀来匹配一系列域名<br>大小写的环境变量都设置了一遍，因为在实际工作中发现存在着一些应用或命令只识别大写或小写</p></blockquote><h1 id="Ansible脚本设置网络代理"><a href="#Ansible脚本设置网络代理" class="headerlink" title="Ansible脚本设置网络代理"></a>Ansible脚本设置网络代理</h1><p>以上设置网络代理的方式其实就是我们所说的ad-hoc脚本的方式，但是ad-hoc脚本在不同的Windows系统中移植性比较差，往往需要一些改动才能运行。使用配置管理工具比如Ansible来设置网络代理往往会带来两个好处：</p><ul><li>可移植性</li><li>更少的代码</li></ul><p>这也是我们所说的“现成的工具优先于专门脚本(tool over ad-hoc)”这一最佳实践。</p><p>以下是Ansible脚本样本：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">IE</span> <span class="hljs-string">proxy</span> <span class="hljs-string">settings</span> <span class="hljs-string">to</span> <span class="hljs-string">apply</span> <span class="hljs-string">to</span> <span class="hljs-string">all</span> <span class="hljs-string">users</span><br>  <span class="hljs-attr">win_regedit:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">HKLM:\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet</span> <span class="hljs-string">Settings</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">ProxySettingsPerUser</span><br>    <span class="hljs-attr">data:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">dword</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">IE</span> <span class="hljs-string">to</span> <span class="hljs-string">use</span> <span class="hljs-string">a</span> <span class="hljs-string">specific</span> <span class="hljs-string">proxy</span> <span class="hljs-string">per</span> <span class="hljs-string">protocol</span> <span class="hljs-string">using</span> <span class="hljs-string">a</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">win_inet_proxy:</span><br>    <span class="hljs-attr">proxy:</span> <span class="hljs-string">http=&#123;&#123;win_init_http_proxy&#125;&#125;;https=&#123;&#123;win_init_https_proxy&#125;&#125;;ftp=&#123;&#123;win_init_ftp_proxy&#125;&#125;</span><br>    <span class="hljs-attr">bypass:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123;win_init_no_proxy&#125;&#125;</span>&quot;</span><br><br><span class="hljs-comment"># This should be done after setting the IE proxy with win_inet_proxy</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Import</span> <span class="hljs-string">IE</span> <span class="hljs-string">proxy</span> <span class="hljs-string">configuration</span> <span class="hljs-string">to</span> <span class="hljs-string">WinHTTP</span><br>  <span class="hljs-attr">win_http_proxy:</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">ie</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Linux</span> <span class="hljs-string">style</span> <span class="hljs-string">http</span> <span class="hljs-string">proxy</span><br>  <span class="hljs-attr">win_environment:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http_proxy</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123;linux_style_init_http_proxy&#125;&#125;</span>&#x27;</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-string">machine</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Linux</span> <span class="hljs-string">style</span> <span class="hljs-string">https</span> <span class="hljs-string">proxy</span><br>  <span class="hljs-attr">win_environment:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">https_proxy</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123;linux_style_init_https_proxy&#125;&#125;</span>&#x27;</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-string">machine</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Linux</span> <span class="hljs-string">style</span> <span class="hljs-literal">no</span> <span class="hljs-string">proxy</span><br>  <span class="hljs-attr">win_environment:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">no_proxy</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123;linux_style_init_no_proxy&#125;&#125;</span>&#x27;</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-string">machine</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Linux</span> <span class="hljs-string">style</span> <span class="hljs-string">HTTP</span> <span class="hljs-string">proxy</span><br>  <span class="hljs-attr">win_environment:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">HTTP_PROXY</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123;linux_style_init_http_proxy&#125;&#125;</span>&#x27;</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-string">machine</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Linux</span> <span class="hljs-string">style</span> <span class="hljs-string">HTTPS</span> <span class="hljs-string">proxy</span><br>  <span class="hljs-attr">win_environment:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">HTTPS_PROXY</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123;linux_style_init_https_proxy&#125;&#125;</span>&#x27;</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-string">machine</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Linux</span> <span class="hljs-string">style</span> <span class="hljs-literal">NO</span> <span class="hljs-string">proxy</span><br>  <span class="hljs-attr">win_environment:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">NO_PROXY</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123;linux_style_init_no_proxy&#125;&#125;</span>&#x27;</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-string">machine</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br></code></pre></td></tr></table></figure><p>变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">win_init_http_proxy:</span> <span class="hljs-string">&quot;&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-attr">win_init_https_proxy:</span> <span class="hljs-string">&quot;&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-attr">win_init_ftp_proxy:</span> <span class="hljs-string">&quot;&lt;server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-attr">win_init_no_proxy:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&lt;local&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*.xxxx.com&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;192.168.56.*&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10.0.0.*&quot;</span><br><br><span class="hljs-attr">linux_style_init_http_proxy:</span> <span class="hljs-string">http://&lt;server&gt;:&lt;port&gt;</span><br><span class="hljs-attr">linux_style_init_https_proxy:</span> <span class="hljs-string">http://&lt;server&gt;:&lt;port&gt;</span><br><span class="hljs-attr">linux_style_init_ftp_proxy:</span> <span class="hljs-string">http://&lt;server&gt;:&lt;port&gt;</span><br><span class="hljs-attr">linux_style_init_no_proxy:</span> <span class="hljs-string">&quot;localhost,127.0.0.1,.xxxx.com,xxxx.com,192.168.0.5&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装Python并搭建Python的虚拟开发环境</title>
    <link href="/2020/01/31/install-python/"/>
    <url>/2020/01/31/install-python/</url>
    
    <content type="html"><![CDATA[<p>虽然Python的安装之于开发来说比较简单，但弄清楚Python及其相关工具在各个平台上的安装对于之后的开发，打包都是很有帮助的，正所谓工欲善其事，必先利其器！本文将介绍如何在Mac，Windows，Ubuntu和CentOS中同时安装和设置Python2和Python3，以及利用virtualenv命令创建Python的虚拟开发环境。为什么要Python2和Python3共存？尽管官方已经不支持Python2了，但还是有很多Python2的程序存在，有很多Python2的库没有迁移到Python3，所以在很长的一段时间里是需要Python2和Python3的开发和运行环境共存。</p><span id="more"></span><h1 id="在Mac中安装Python2和Python3"><a href="#在Mac中安装Python2和Python3" class="headerlink" title="在Mac中安装Python2和Python3"></a>在Mac中安装Python2和Python3</h1><p>从Python的官网中下载Python的Mac安装包，按照向导缺省安装即可。<br><img src="/2020/01/31/install-python/7.png"></p><p><img src="/2020/01/31/install-python/8.png"></p><h2 id="设置Python3为缺省的Python"><a href="#设置Python3为缺省的Python" class="headerlink" title="设置Python3为缺省的Python"></a>设置Python3为缺省的Python</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">rm</span> /Library/Frameworks/Python.framework/Versions/Current<br>sudo <span class="hljs-built_in">ln</span> -s /Library/Frameworks/Python.framework/Versions/3.8 /Library/Frameworks/Python.framework/Versions/Current<br><span class="hljs-built_in">cd</span> /usr/local/bin/<br>sudo python<br>sudo <span class="hljs-built_in">ln</span> -s ../../../Library/Frameworks/Python.framework/Versions/3.8/bin/python3 python<br>sudo <span class="hljs-built_in">rm</span> pip<br>sudo <span class="hljs-built_in">ln</span> -s ../../../Library/Frameworks/Python.framework/Versions/3.8/bin/pip3 pip<br></code></pre></td></tr></table></figure><p>这样，在Mac中缺省的是Python3，命令行直接调用python或pip即可。如果需要使用Python2，命令行调用python2或pip2。</p><p>在文件“~&#x2F;.bash_profile”中注释掉或者删除Python安装程序添加的PATH环境变量，因为我们已经在系统路径&#x2F;usr&#x2F;local&#x2F;bin下建立了Python相关命令的软链接，而且许多工具缺省也是从这个路径下搜索Python的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Setting PATH for Python 3.8</span><br><span class="hljs-comment"># The original version is saved in .bash_profile.pysave</span><br><span class="hljs-comment">#PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.8/bin:$&#123;PATH&#125;&quot;</span><br><span class="hljs-comment">#export PATH</span><br><br><span class="hljs-comment"># Setting PATH for Python 2.7</span><br><span class="hljs-comment"># The original version is saved in .bash_profile.pysave</span><br><span class="hljs-comment">#PATH=&quot;/Library/Frameworks/Python.framework/Versions/2.7/bin:$&#123;PATH&#125;&quot;</span><br><span class="hljs-comment">#export PATH</span><br></code></pre></td></tr></table></figure><h2 id="升级pip工具"><a href="#升级pip工具" class="headerlink" title="升级pip工具"></a>升级pip工具</h2><p>Python安装包里包含的pip工具可能不是最新版本，所以需要升级一下。</p><h3 id="缺省python3"><a href="#缺省python3" class="headerlink" title="缺省python3"></a>缺省python3</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl https://bootstrap.pypa.io/get-pip.py | sudo -E -H /usr/loca/bin/python<br></code></pre></td></tr></table></figure><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl https://bootstrap.pypa.io/get-pip.py | sudo -E -H /usr/local/bin/  python2<br></code></pre></td></tr></table></figure><h2 id="安装virtualenv工具"><a href="#安装virtualenv工具" class="headerlink" title="安装virtualenv工具"></a>安装virtualenv工具</h2><h3 id="缺省Python3"><a href="#缺省Python3" class="headerlink" title="缺省Python3"></a>缺省Python3</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install virtualenv<br><span class="hljs-built_in">cd</span> /usr/local/bin/<br>sudo <span class="hljs-built_in">ln</span> -s ../../../Library/Frameworks/Python.framework/Versions/3.8/bin/virtualenv virtualenv<br></code></pre></td></tr></table></figure><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip2 install virtualenv<br><span class="hljs-built_in">cd</span> /usr/local/bin/<br>sudo <span class="hljs-built_in">ln</span> -s ../../../Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenv virtualenv2<br></code></pre></td></tr></table></figure><h2 id="创建Python的虚拟开发环境"><a href="#创建Python的虚拟开发环境" class="headerlink" title="创建Python的虚拟开发环境"></a>创建Python的虚拟开发环境</h2><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">virtualenv --always-copy pyenv3<br></code></pre></td></tr></table></figure><h3 id="Python2-1"><a href="#Python2-1" class="headerlink" title="Python2"></a>Python2</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">virtualenv --always-copy -p python2 pyenv2<br></code></pre></td></tr></table></figure><h1 id="在CentOS中安装Python2和Python3"><a href="#在CentOS中安装Python2和Python3" class="headerlink" title="在CentOS中安装Python2和Python3"></a>在CentOS中安装Python2和Python3</h1><p>Python的官方文档并没有提供Linux的二进制安装包或者提供yum的安装方法，因为大部分Linux都包含了Python。但是Linux缺省自带的Python都不是最新版本，比如CentOS 7缺省自带Python2.7.5， 所以我们需要通过源代码构建并安装最新版的Python。</p><h2 id="安装构建Python2和Python3的依赖"><a href="#安装构建Python2和Python3的依赖" class="headerlink" title="安装构建Python2和Python3的依赖"></a>安装构建Python2和Python3的依赖</h2><p><a href="https://devguide.python.org/setup/#linux">参考官方文档</a>，执行以下shell命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install yum-utils<br>sudo yum-builddep python3<br></code></pre></td></tr></table></figure><blockquote><p>也可以显式安装所有的依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 首先确保你的系统是最新的:</span><br>yum update<br><span class="hljs-comment"># 安装编译器和相关的工具:</span><br>yum groupinstall -y <span class="hljs-string">&quot;development tools&quot;</span><br><span class="hljs-comment"># 安装编译全功能Python所需的依赖库:</span><br>yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libffi-devel libpcap-devel xz-devel expat-devel<br><span class="hljs-comment"># 如果你的CentOS是”最小化“安装，你需要安装wget工具：</span><br>yum install -y wget<br></code></pre></td></tr></table></figure></blockquote><h2 id="源码安装Python2和Python3"><a href="#源码安装Python2和Python3" class="headerlink" title="源码安装Python2和Python3"></a>源码安装Python2和Python3</h2><ol><li><p>下载最新Python2的源代码并解压<br><a href="https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz">https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz</a></p></li><li><p>下载最新Python3的源代码并解压<br><a href="https://www.python.org/ftp/python/3.8.3/Python-3.8.3.tgz">https://www.python.org/ftp/python/3.8.3/Python-3.8.3.tgz</a></p></li><li><p>分别在Python2和Python3的源码根目录中执行下面命令配置，构建并安装Python2和Python3</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">./configure --prefix=/usr/local --enable-shared LDFLAGS=<span class="hljs-string">&quot;-Wl,-rpath /usr/local/lib&quot;</span><br>make &amp;&amp; make altinstall<br></code></pre></td></tr></table></figure><blockquote><p>为了区别CentOS中缺省的自带Python，用altinstall将Python安装到不同的路径下。<br>下面是Python2的安装目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/local/bin/<br>/usr/local/lib/<br>/usr/local/lib/python3.8/<br>/usr/local/lib/python2.7/<br></code></pre></td></tr></table></figure></blockquote></li><li><p>设置Python3为缺省的Python</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/bin<br>sudo <span class="hljs-built_in">ln</span> -s python3.8 python3<br>sudo <span class="hljs-built_in">ln</span> -s python3 python<br>sudo <span class="hljs-built_in">ln</span> -s python2.7 python2<br></code></pre></td></tr></table></figure></li></ol><h2 id="安装或升级pip工具"><a href="#安装或升级pip工具" class="headerlink" title="安装或升级pip工具"></a>安装或升级pip工具</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl https://bootstrap.pypa.io/get-pip.py | sudo -E -H /usr/local/bin/python<br>curl https://bootstrap.pypa.io/get-pip.py | sudo -E -H /usr/local/bin/python2<br><span class="hljs-built_in">cd</span> /usr/local/bin<br>sudo <span class="hljs-built_in">rm</span> pip<br>sudo <span class="hljs-built_in">ln</span> -s pip3 pip<br></code></pre></td></tr></table></figure><h2 id="安装virtualenv工具-1"><a href="#安装virtualenv工具-1" class="headerlink" title="安装virtualenv工具"></a>安装virtualenv工具</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo -E -H /usr/local/bin/pip2 install virtualenv<br>sudo <span class="hljs-built_in">mv</span> virtualenv virtualenv2<br>sudo -E -H /usr/local/bin/pip install virtualenv<br></code></pre></td></tr></table></figure><h2 id="创建Python的虚拟开发环境-1"><a href="#创建Python的虚拟开发环境-1" class="headerlink" title="创建Python的虚拟开发环境"></a>创建Python的虚拟开发环境</h2><h3 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">virtualenv --always-copy pyenv3<br></code></pre></td></tr></table></figure><h3 id="Python2-2"><a href="#Python2-2" class="headerlink" title="Python2"></a>Python2</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">virtualenv --always-copy -p python2 pyenv2<br></code></pre></td></tr></table></figure><h1 id="在Ubuntu中安装Python2和Python3"><a href="#在Ubuntu中安装Python2和Python3" class="headerlink" title="在Ubuntu中安装Python2和Python3"></a>在Ubuntu中安装Python2和Python3</h1><p>与CentOS相同，我们需要通过源代码构建并安装最新版的Python。</p><h2 id="安装构建Python3和Python2的依赖"><a href="#安装构建Python3和Python2的依赖" class="headerlink" title="安装构建Python3和Python2的依赖"></a>安装构建Python3和Python2的依赖</h2><p><a href="https://devguide.python.org/setup/#linux">参考官方文档</a>，编辑&#x2F;etc&#x2F;apt&#x2F;sources.list，为Ubuntu 18添加“deb-src <a href="http://archive.ubuntu.com/ubuntu/">http://archive.ubuntu.com/ubuntu/</a> bionic main”，或为Ubuntu 16添加“deb-src <a href="http://archive.ubuntu.com/ubuntu/">http://archive.ubuntu.com/ubuntu/</a> xenial main”。执行下面命令安装编译Python2或Python3的依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get build-dep python3.6<br></code></pre></td></tr></table></figure><blockquote><p>如果依赖包的版本找不到，试着降低小版本号，比如python3.5。</p></blockquote><h2 id="源码安装Python2和Python3-1"><a href="#源码安装Python2和Python3-1" class="headerlink" title="源码安装Python2和Python3"></a>源码安装Python2和Python3</h2><p>与CentOS的过程一样，可以参照CentOS章节。</p><h2 id="PPA-Personal-Package-Archive-安装Python"><a href="#PPA-Personal-Package-Archive-安装Python" class="headerlink" title="PPA(Personal Package Archive)安装Python"></a>PPA(Personal Package Archive)安装Python</h2><p><a href="https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa">PPA</a>库包含了为Ubuntu打包的最新的Python版本，但不一定包含所有的版本，所以不是太推荐这个方法。以下是通过PPA安装Python3.8的步骤：</p><h3 id="为apt添加PPA库"><a href="#为apt添加PPA库" class="headerlink" title="为apt添加PPA库"></a>为apt添加PPA库</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get update<br>sudo apt install -y software-properties-common<br>sudo -E -H add-apt-repository -y ppa:deadsnakes/ppa<br>sudo apt-get update<br></code></pre></td></tr></table></figure><h3 id="安装Python3-8"><a href="#安装Python3-8" class="headerlink" title="安装Python3.8"></a>安装Python3.8</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get -y -f --allow-unauthenticated install python3.8-dev<br></code></pre></td></tr></table></figure><h1 id="在Windows中安装Python2和Python3"><a href="#在Windows中安装Python2和Python3" class="headerlink" title="在Windows中安装Python2和Python3"></a>在Windows中安装Python2和Python3</h1><p>在Windows中同时安装Python2和Python3相对来说比较容易，下载对应的安装包，按向导安装到缺省目录下即可。<br><img src="/2020/01/31/install-python/1.png"></p><p>在安装Python2向导中，选择同时安装工具pip以及将python.exe加入Path环境变量中：<br><img src="/2020/01/31/install-python/2.png"></p><p>在安装Python3向导中，选择自定义安装：<br><img src="/2020/01/31/install-python/3.png"></p><p>并选择安装工具pip：<br><img src="/2020/01/31/install-python/4.png"></p><p>将安装目录设置到和Python2相同的地方C:\Python37：<br><img src="/2020/01/31/install-python/5.png"></p><p>如果要设置Python2为缺省的Python，可以将C:\Python27;C:\Python27\Scripts放到Python3的配置前面：<br><img src="/2020/01/31/install-python/6.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins构建GitHub合并请求(Pull Request)</title>
    <link href="/2020/01/30/jenkins-github-pullrequest/"/>
    <url>/2020/01/30/jenkins-github-pullrequest/</url>
    
    <content type="html"><![CDATA[<p>在我的文章<a href="http://www.mikesay.com/2020/01/29/pullrequest-essential/">“Git合并请求(pull&#x2F;merge request)的本质”</a>中已经说明了合并请求(pull&#x2F;merge request)在代码层面上实际是Git仓库中的一个特殊分支，它指向了私有分支和主分支临时合并后产生的合并提交(merge commit)。如果我们能够在这个合并请求(pull&#x2F;merge request)被真正合并进主分支之前对它做一次构建，就能尽早发现私有分支上的代码是否有问题，从而将问题拦截在主分支之外，减少主分支上持续交付流水线的失败率。对合并请求(pull&#x2F;merge request)的构建除了编译代码(必要时可增量编译)和单元测试外，还可以增加更多额外的检查，比如代码的静态扫描。业界把这个放在持续交付流水线之前的检查称为preflight流水线(可参考《Continuous Delivery》这本书第三章67页对preflight构建的详细介绍)。本文将介绍如何配置Jenkins和Github来构建Github合并请求(Pull Request)。</p><span id="more"></span><h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="安装Github-Pull-Request-Builder插件"><a href="#安装Github-Pull-Request-Builder插件" class="headerlink" title="安装Github Pull Request Builder插件"></a>安装Github Pull Request Builder插件</h2><ol><li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins打开Plugin Manager页面</p></li><li><p>打开Available页面，选择Github Pull Request Builder，点击Install without restart按钮<br><img src="/2020/01/30/jenkins-github-pullrequest/1.png"></p></li><li><p>必要时重启Jenkins让插件生效</p></li></ol><h2 id="配置Github-Pull-Request-Builder插件"><a href="#配置Github-Pull-Request-Builder插件" class="headerlink" title="配置Github Pull Request Builder插件"></a>配置Github Pull Request Builder插件</h2><ol><li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Config System打开系统配置页面</p></li><li><p>定位到”Github Pull Request Builder“插件，点击Add菜单打开创建Jenkins认证信息对话框<br><img src="/2020/01/30/jenkins-github-pullrequest/2.png"></p></li><li><p>创建”Username with password”类型的凭证，用户名和密码是有足够权限的Github账号和密码<br><img src="/2020/01/30/jenkins-github-pullrequest/3.png"></p></li><li><p>配置GitHub Server API URL，选择步骤3创建的凭证，可以点击”Connect to API”按钮测试基本连接<br><img src="/2020/01/30/jenkins-github-pullrequest/4.png"></p><p>对于GitHub Server API URL的值，GitHub和GitHub Enterprise是有区别的：</p><table><thead><tr><th>GitHub Server</th><th>API Endpoint</th><th>说明</th></tr></thead><tbody><tr><td>GitHub Enterprise</td><td>http(s):&#x2F;&#x2F;[hostname]&#x2F;api&#x2F;v3</td><td></td></tr><tr><td>GitHub</td><td><a href="https://api.github.com/">https://api.github.com</a></td><td>Receive the v3 version of the REST API.</td></tr></tbody></table></li><li><p>点击”Save”按钮保存配置</p></li></ol><h1 id="配置Github代码仓库"><a href="#配置Github代码仓库" class="headerlink" title="配置Github代码仓库"></a>配置Github代码仓库</h1><ol><li><p>打开Git仓库设置页面，点击Hooks -&gt; Add webhook<br><img src="/2020/01/30/jenkins-github-pullrequest/5.png"></p></li><li><p>输入Palyload URL(<code>http://jenkins-url/github-webhook/</code>)，选择Content Type为application&#x2F;json<br><img src="/2020/01/30/jenkins-github-pullrequest/6.png"></p></li><li><p>选择”Let me select individual envents”自定义webhook触发事件<br><img src="/2020/01/30/jenkins-github-pullrequest/7.png"></p></li><li><p>只选择”Pull requests”事件，并点击”Add webhook”保存Webhook<br><img src="/2020/01/30/jenkins-github-pullrequest/8.png"></p></li></ol><h1 id="创建Jenkins-pipeline-job用来构建合并请求-pull-x2F-merge-request"><a href="#创建Jenkins-pipeline-job用来构建合并请求-pull-x2F-merge-request" class="headerlink" title="创建Jenkins pipeline job用来构建合并请求(pull&#x2F;merge request)"></a>创建Jenkins pipeline job用来构建合并请求(pull&#x2F;merge request)</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent &#123;<br>        label <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;<br>    environment &#123;<br>        GITHUB_URL = <span class="hljs-string">&quot;http://xxx.github.xxxx.com&quot;</span><br>        GITHUB_ORG = <span class="hljs-string">&quot;MikeSay&quot;</span><br>        GITHUB_REPO = <span class="hljs-string">&quot;mikesay-test-1&quot;</span><br>    &#125;<br>    options &#123;<br>        skipDefaultCheckout()<br>        ansiColor(<span class="hljs-string">&#x27;xterm&#x27;</span>)<br>    &#125;<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;Checkout&#x27;</span>) &#123;<br>            steps &#123;<br>                script&#123;<br>                    <span class="hljs-keyword">def</span> scmVars =   checkout(<br>                                        [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;GitSCM&#x27;</span>, <span class="hljs-attr">branches:</span> [[<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;$&#123;ghprbActualCommit&#125;&quot;</span>]], <br>                                        <span class="hljs-symbol">doGenerateSubmoduleConfigurations:</span> <span class="hljs-literal">false</span>,<br>                                        <span class="hljs-symbol">submoduleCfg:</span> [], <br>                                        <span class="hljs-symbol">extensions:</span> [<br>                                            [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;RelativeTargetDirectory&#x27;</span>, <span class="hljs-attr">relativeTargetDir:</span> <span class="hljs-string">&#x27;codes&#x27;</span>],<br>                                            [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;CleanBeforeCheckout&#x27;</span>]<br>                                        ],<br>                                        <span class="hljs-symbol">userRemoteConfigs:</span> [<br>                                                [<br>                                                    <span class="hljs-symbol">credentialsId:</span> <span class="hljs-string">&#x27;ghe_account&#x27;</span>, <br>                                                    <span class="hljs-symbol">name:</span> <span class="hljs-string">&#x27;origin&#x27;</span>, <br>                                                    <span class="hljs-symbol">refspec:</span> <span class="hljs-string">&#x27;+refs/pull/*:refs/remotes/origin/pr/*&#x27;</span>, <br>                                                    <span class="hljs-symbol">url:</span> <span class="hljs-string">&quot;$&#123;GITHUB_URL&#125;/$&#123;GITHUB_ORG&#125;/$&#123;GITHUB_REPO&#125;.git&quot;</span><br>                                                ]<br>                                            ]<br>                                        ]<br>                                    )<br>                    env.GIT_BRANCH = <span class="hljs-string">&quot;$&#123;scmVars.GIT_BRANCH&#125;&quot;</span><br>                    env.GIT_COMMIT = <span class="hljs-string">&quot;$&#123;scmVars.GIT_COMMIT&#125;&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;<br>            steps &#123;<br>                dir(<span class="hljs-string">&#x27;codes&#x27;</span>) &#123;<br>                    sh <span class="hljs-string">&#x27;&#x27;&#x27;#!/bin/bash -l</span><br><span class="hljs-string">                        echo &quot;Start building!&quot;</span><br><span class="hljs-string">                        cat README.md</span><br><span class="hljs-string">                    &#x27;&#x27;&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>    post &#123;<br>        always &#123;<br>            junit <span class="hljs-attr">allowEmptyResults:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">testResults:</span> <span class="hljs-string">&#x27;codes/build/test-results/test/**/*.xml&#x27;</span><br>            <span class="hljs-comment">// send to email</span><br>            emailext(<br>                <span class="hljs-symbol">subject:</span> <span class="hljs-string">&#x27;$DEFAULT_SUBJECT&#x27;</span>,<br>                <span class="hljs-symbol">body:</span> <span class="hljs-string">&#x27;$DEFAULT_CONTENT&#x27;</span>,<br>                <span class="hljs-symbol">recipientProviders:</span> [<br>                [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;CulpritsRecipientProvider&#x27;</span>],<br>                [<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;RequesterRecipientProvider&#x27;</span>],<br>                [<span class="hljs-attr">$class :</span> <span class="hljs-string">&#x27;DevelopersRecipientProvider&#x27;</span>]<br>                ],<br>                <span class="hljs-symbol">replyTo:</span> <span class="hljs-string">&#x27;$DEFAULT_REPLYTO&#x27;</span>,<br>                <span class="hljs-symbol">to:</span> <span class="hljs-string">&#x27;$DEFAULT_RECIPIENTS&#x27;</span><br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>30行: 添加refspec获取合并请求(pull&#x2F;merge request)的分支信息</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">refspec:</span> <span class="hljs-string">&#x27;+refs/pull/*:refs/remotes/origin/pr/*&#x27;</span><br></code></pre></td></tr></table></figure><p>19行: branches选择环境变量”ghprbActualCommit”，它是合并请求(pull&#x2F;merge request)分支对应的提交号</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">[<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;GitSCM&#x27;</span>, <span class="hljs-attr">branches:</span> [[<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;$&#123;ghprbActualCommit&#125;&quot;</span>]]<br></code></pre></td></tr></table></figure><p>除了”ghprbActualCommit”外，github pull request builder插件还往当前构建中注入了许多变量供构建Job使用，如下表：</p><table><thead><tr><th>变量</th><th>事例值</th><th>说明</th></tr></thead><tbody><tr><td>sha1</td><td>origin&#x2F;pr&#x2F;6&#x2F;merge</td><td>合并请求(pull&#x2F;merge request)分支。在构建Job中也可以用${sha1}来代替${ghprbActualCommit}</td></tr><tr><td>ghprbAuthorRepoGitUrl</td><td><a href="http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1.git">http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1.git</a></td><td>合并请求(pull&#x2F;merge request)所在仓库的http地址</td></tr><tr><td>ghprbPullId</td><td>6</td><td>合并请求(pull&#x2F;merge request)的ID号</td></tr><tr><td>ghprbTargetBranch</td><td>master</td><td>合并请求(pull&#x2F;merge request)的主分支</td></tr><tr><td>ghprbSourceBranch</td><td>test9</td><td>合并请求(pull&#x2F;merge request)的私有分支</td></tr><tr><td>ghprbPullTitle</td><td>Test9.</td><td>合并请求(pull&#x2F;merge request)的标题</td></tr><tr><td>ghprbPullLink</td><td><a href="http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1/pull/6">http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1/pull/6</a></td><td>合并请求(pull&#x2F;merge request)的http地址</td></tr></tbody></table><p>可以从当前合并请求(pull&#x2F;merge request)的构建参数中获得所有变量名和当前值：<br><img src="/2020/01/30/jenkins-github-pullrequest/16.png"></p><h2 id="创建Jenkins-job引用Jenkinsfile"><a href="#创建Jenkins-job引用Jenkinsfile" class="headerlink" title="创建Jenkins job引用Jenkinsfile"></a>创建Jenkins job引用Jenkinsfile</h2><ol><li><p>点击”New Item”</p></li><li><p>选择Job类型为”Pipeline”，输入Job的名字”github-preflight”，点击”Ok”按钮<br><img src="/2020/01/30/jenkins-github-pullrequest/9.png"></p></li><li><p>在”GitHub Project”段，输入”Project url”。注，”Project url”是Git仓库的http地址去除”.git”后缀<br><img src="/2020/01/30/jenkins-github-pullrequest/10.png"></p></li><li><p>在”Build Triggers”段，选择”GitHub Pull Request Builder”<br><img src="/2020/01/30/jenkins-github-pullrequest/11.png"></p><ul><li>GitHub API credentials: 之前配置的GitHub API</li><li>Trigger phrase: 在合并请求(pull&#x2F;merge request)的注释或标题里加入trigger phrase内容会自动触发新的构建</li><li>Skip build phrase: 在合并请求(pull&#x2F;merge request)的注释或标题里加入skip build phrase内容则不会触发构建</li></ul></li><li><p>如果需要构建每个合并请求(pull&#x2F;merge request)，勾选”Build every pull request automatically without asking (Dangerous)”，在”Whitelist Target Branches”输入主分支”master”<br><img src="/2020/01/30/jenkins-github-pullrequest/12.png"></p></li><li><p>在”Pipeline”段，引用Jenkinsfile<br><img src="/2020/01/30/jenkins-github-pullrequest/13.png"></p></li></ol><h1 id="创建合并请求-pull-x2F-merge-request-触发构建"><a href="#创建合并请求-pull-x2F-merge-request-触发构建" class="headerlink" title="创建合并请求(pull&#x2F;merge request)触发构建"></a>创建合并请求(pull&#x2F;merge request)触发构建</h1><ol><li><p>Github的合并请求(pull&#x2F;merge request)<br><img src="/2020/01/30/jenkins-github-pullrequest/14.png"></p></li><li><p>触发的构建<br><img src="/2020/01/30/jenkins-github-pullrequest/15.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git合并请求(Pull/Merge request)的本质</title>
    <link href="/2020/01/29/pullrequest-essential/"/>
    <url>/2020/01/29/pullrequest-essential/</url>
    
    <content type="html"><![CDATA[<p>Git以及基于Git的各代码开发协作平台，比如Github, Gitlab, Bitbucket, TFS Git等正逐渐成为首选的代码版本管理工具，而基于Git的基本开发流程则是开发者创建个人的私有分支并在个人的私有分支上提交代码，代码完成后创建合并请求(pull&#x2F;merge request)到主分支让相关人员做代码评审，评审通过后将合并请求(pull&#x2F;merge request)合并到主分支上。合并请求(pull&#x2F;merge request)不是Git本身的特性，而是各代码协作平台提供的特性，它提供的代码评审功能几乎取代了独立的代码评审工具，同时它也方便了分布于世界各地的开源代码贡献者合并自己的代码。那么合并请求(pull&#x2F;merge request)到底是什么东西？它看的见摸得着吗？本文将通过目前比较流行的代码开发协作平台(Github, Gitlab, Bitbucket, TFS Git)对合并请求(pull&#x2F;merget request)的实现来阐明合并请求(pull&#x2F;merge request)的本质。<span id="more"></span></p><p>实际上，合并请求(pull&#x2F;merge request)在代码层面上是Git仓库中的一个特殊分支。当开发在代码协作平台上创建并提交合并请求(pull&#x2F;merge request)后，代码协作平台在服务器端将私有分支和主分支临时合并产生一个合并提交(merge commit)，同时创建一个特殊分支指向这个合并提交(merge commit)。如果临时合并出现冲突，则在Web层面显示有冲突，需要开发提交新的代码到个人分支以消除冲突。</p><p>要真正的理解合并请求(pull&#x2F;merge request)这一特殊分支，我们需要先理解下Git的分支。</p><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>相对于传统的版本管理工具创建分支的操作，Git的分支方式及其轻巧，分支操作几乎是实时的，并且在分支之前切换也非常快。许多人认为Git这一分支模式算得上是一个“杀手级”功能。下图描述了一个含有三个文件的文件夹，且只有一个提交的Git仓库：</p><p><img src="/2020/01/29/pullrequest-essential/1.png"></p><p>在Git中，数据是以树形结构存储，每个文件对应着一个blob对象，每个文件夹对应着一个tree对象。每一次Git提交(commit)，都会根据文件或路径的变化创建一系列新的blog对象或tree对象，checksum不变的对象会被重复引用，其中最顶层的tree对象由于每次都需要变化，所以每次都会创建新的顶层tree对象，同时会创建一个commit对象指向新的顶层tree对象，整个过程犹如给数据做了个快照，而当前的commit对象则是这个快照的标签。如果要获取这个快照对应的代码，只要git checkout到这个commit对象即可。</p><p>当再次提交时，新创建的commit对象会保存一个指针指向前面的一个commit对象形成一个提交链(快照链)。下图就是Git仓库中的一个提交链：</p><p><img src="/2020/01/29/pullrequest-essential/2.png"></p><p>而Git中的分支则是一个轻量的可移动的指针指向其中一个commit对象。缺省的分支名字叫master，每一次新的提交master分支都会移动并指向到最新的commit对象。下图是Git中的分支和提交历史：</p><p><img src="/2020/01/29/pullrequest-essential/3.png"></p><p>HEAD对象是指针的指针，它指向当前所在的分支。切换分支时，只要将HEAD指向新的分支即可，所以说Git切换分支的操作是相当轻量的。</p><p>所以正如前文所说，合并请求(pull&#x2F;merge request)也是个分支，也就是指针，它是指向私有分支和主分支临时合并后产生的合并提交(commit)对象。下图是Git中的合并请求(pull&#x2F;merge request)分支：</p><p><img src="/2020/01/29/pullrequest-essential/4.png"></p><p>如图”defect235”分支是为了修复defect235而创建的私有分支，commit”f40ac”是代码协作平台临时合并分支”defect235”和”master”而创建的合并提交对象，分支”refs&#x2F;pull&#x2F;1&#x2F;merge”则是那个特殊的分支，指向合并提交对象”f40ac”。不过,常规的Git克隆或者拉取是无法获取这个分支信息的，因为常规Git只会认为在缺省路径“refs&#x2F;heads&#x2F;“下的分支是Git分支。当开发在Web界面中合并合并请求(pull&#x2F;merge request)后，私有分支”defect235”和特殊的分支也会被删除掉(通常代码协作平台会提供一些设置来控制是否要删除私有分支和合并请求分支)。下图是Git中合并请求被合并后的分支情况：</p><p><img src="/2020/01/29/pullrequest-essential/5.png"></p><p>不同的代码协作平台在实现合并请求(pull&#x2F;merget request)的原理上是相同的，但是也有一些细微的差别。</p><h1 id="GitHub合并请求-Pull-Request"><a href="#GitHub合并请求-Pull-Request" class="headerlink" title="GitHub合并请求(Pull Request)"></a>GitHub合并请求(Pull Request)</h1><ul><li><p>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(pull request)的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">  git config --add remote.origin.fetch +refs/pull/*:refs/remotes/origin/pr/*<br>  git pull --rebase<br>  git branch -a<br><br>  add_test<br>* master<br>  remotes/origin/HEAD -&gt; origin/master<br>  remotes/origin/add_test<br>  remotes/origin/master<br>  remotes/origin/pr/1/head<br>  remotes/origin/pr/1/merge<br><br>  git checkout  -b <span class="hljs-built_in">pr</span>/1 origin/pr/1/merge<br></code></pre></td></tr></table></figure><p>origin&#x2F;pr&#x2F;1&#x2F;head: 指向当前合并请求(pull request)中的私有分支<br>origin&#x2F;pr&#x2F;1&#x2F;merge: 指向临时合并的提交对象</p></li><li><p>仅拉取某个合并请求(pull request)的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin +refs/pull/1/*:refs/remotes/origin/pr/1/*<br>git checkout  -b <span class="hljs-built_in">pr</span>/1 origin/pr/1/merge<br></code></pre></td></tr></table></figure></li></ul><h1 id="GitLab合并请求-Merge-Request"><a href="#GitLab合并请求-Merge-Request" class="headerlink" title="GitLab合并请求(Merge Request)"></a>GitLab合并请求(Merge Request)</h1><ul><li><p>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(merge request)的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">  git config --add remote.origin.fetch +refs/merge-requests/*:refs/remotes/origin/mr/*<br>  git pull --rebase<br>  git branch -a<br><br>  change2<br>  change_readme<br>* master<br>  remotes/origin/HEAD -&gt; origin/master<br>  remotes/origin/change2<br>  remotes/origin/change_readme<br>  remotes/origin/master<br>  remotes/origin/mr/1/head<br>  remotes/origin/mr/2/head<br><br>  git checkout -b mr/2 origin/mr/2/head<br></code></pre></td></tr></table></figure><p>origin&#x2F;mr&#x2F;1&#x2F;head: 指向临时合并的提交对象</p></li><li><p>仅拉取某个合并请求(pull request)的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin +refs/merge-requests/2/*:refs/remotes/origin/mr/2/*<br>git checkout -b mr/2 origin/mr/2/head<br></code></pre></td></tr></table></figure></li></ul><h1 id="Bitbuckt合并请求-pull-Request"><a href="#Bitbuckt合并请求-pull-Request" class="headerlink" title="Bitbuckt合并请求(pull Request)"></a>Bitbuckt合并请求(pull Request)</h1><ul><li><p>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(pull request)的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">  git config --add remote.origin.fetch +refs/pull-requests/*:refs/remotes/origin/pr/*<br>  git pull --rebase<br>  git branch -a<br><br>  fix_defect1<br>* master<br>  remotes/origin/fix_defect1<br>  remotes/origin/master<br>  remotes/origin/pr/1/from<br>  remotes/origin/pr/1/merge<br><br>  git checkout -b <span class="hljs-built_in">pr</span>/1 origin/pr/1/merge<br></code></pre></td></tr></table></figure><p>origin&#x2F;pr&#x2F;1&#x2F;from: 指向当前合并请求(pull request)中的私有分支<br>origin&#x2F;pr&#x2F;1&#x2F;merge: 指向临时合并的提交对象</p></li><li><p>仅拉取某个合并请求(pull request)的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin +refs/pull-requests/1/*:refs/remotes/origin/pr/1/*<br>git checkout -b <span class="hljs-built_in">pr</span>/1 origin/pr/1/merge<br></code></pre></td></tr></table></figure></li></ul><h1 id="TFS-Git合并请求-pull-Request"><a href="#TFS-Git合并请求-pull-Request" class="headerlink" title="TFS Git合并请求(pull Request)"></a>TFS Git合并请求(pull Request)</h1><ul><li>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(pull request)的信息  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">  git config --add remote.origin.fetch +refs/pull/*:refs/remotes/origin/pr/*<br>  git pull --rebase<br>  git branch -a<br><br>  fix_defect1<br>* master<br>  remotes/origin/fix_defect1<br>  remotes/origin/master<br>  remotes/origin/pr/1/merge<br><br>  git checkout -b <span class="hljs-built_in">pr</span>/1 origin/pr/1/merge<br></code></pre></td></tr></table></figure></li></ul><p>  origin&#x2F;pr&#x2F;1&#x2F;merge: 指向临时合并的提交对象</p><ul><li>仅拉取某个合并请求(pull request)的信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin +refs/pull/1/*:refs/remotes/origin/pr/1/*<br>git checkout -b <span class="hljs-built_in">pr</span>/1 origin/pr/1/merge<br></code></pre></td></tr></table></figure></li></ul><p>当然，除了上面四个基于Git的代码协作平台外，还有许多优秀的平台，比如国内的码云<a href="https://gitee.com/">https://gitee.com/</a>，各大公有云平台也都提供了自己的代码协作平台。读者可以根据本文的说明自行研究合并请求(pull&#x2F;merge request)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
      <tag>Bitbucket</tag>
      
      <tag>Gitlab</tag>
      
      <tag>TFS Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建容器化的Azure DevOps Agent</title>
    <link href="/2019/12/30/docker-agent-for-azure-devops/"/>
    <url>/2019/12/30/docker-agent-for-azure-devops/</url>
    
    <content type="html"><![CDATA[<p>在一台虚拟机上安装，配置或删除Azure DevOps Agent是需要花费一些步骤和精力的，具体可以参考文档<a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/agents/v2-linux?view=vsts">https://docs.microsoft.com/en-us/vsts/build-release/actions/agents/v2-linux?view=vsts</a>。好消息是Azure DevOps已经支持容器化的方式运行Agent。本文将详细介绍如何创建和启动一个容器化的Agent。</p><span id="more"></span><h1 id="获取Azure-DevOps-Agent的Docker镜像"><a href="#获取Azure-DevOps-Agent的Docker镜像" class="headerlink" title="获取Azure DevOps Agent的Docker镜像"></a>获取Azure DevOps Agent的Docker镜像</h1><h2 id="直接从Docker-Hub上下载"><a href="#直接从Docker-Hub上下载" class="headerlink" title="直接从Docker Hub上下载"></a>直接从Docker Hub上下载</h2><p>在我的Docker Hub空间已经有开箱即用的Docker镜像了。 打开页面<a href="https://hub.docker.com/r/mikejianzhang/azure-agent">https://hub.docker.com/r/mikejianzhang/azure-agent</a>查看详细的下载说明。</p><h2 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h2><p>缺省的开箱即用的Docker镜像并没有包含过多的构建工具。如果这不满足你的需求，可以fork代码仓库<a href="https://github.com/mikejianzhang/azure-agent">https://github.com/mikejianzhang/azure-agent</a>到自己的空间，修改Dockerfile添加更多的工具，再通过以下命令构建新的Docker镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./build.sh azure-agent:&lt;tag&gt;<br></code></pre></td></tr></table></figure><blockquote><p>如果你在公司内部构建镜像，并且需要通过代理才能访问互联网，在构建之前你需要设置http代理。构建脚本“build.sh”支持“http_proxy”, “https_proxy” and “no_proxy”。</p></blockquote><h1 id="运行Azure-DevOps-Agent的Docker镜像"><a href="#运行Azure-DevOps-Agent的Docker镜像" class="headerlink" title="运行Azure DevOps Agent的Docker镜像"></a>运行Azure DevOps Agent的Docker镜像</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在Azure DevOps上创建Agent Pool<br><img src="/2019/12/30/docker-agent-for-azure-devops/1.png"></p></li><li><p>生成Personal Access Token<br><img src="/2019/12/30/docker-agent-for-azure-devops/2.png"></p></li></ol><h2 id="运行Docker镜像"><a href="#运行Docker镜像" class="headerlink" title="运行Docker镜像"></a>运行Docker镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -it -d --name some-agent \<br>        -e AZP_URL=your-azure-devops-url \<br>        -e AZP_TOKEN=your-azure-devops-pat \<br>        -e AZP_AGENT_NAME=some-agent \<br>        -e AZP_POOL=your-azure-devops-agent-pool \<br>        -e AZP_AGENTPACKAGE_URL=the-zure-devops-agent-package \<br>        azure-agent:&lt;tag&gt;<br></code></pre></td></tr></table></figure><p>环境变量说明：</p><table><thead><tr><th>变量名</th><th>必需</th><th>说明</th></tr></thead><tbody><tr><td>AZP_URL</td><td>是</td><td>你的 Azure DevOps server url. i.e. https:&#x2F;&#x2F;<host>&#x2F;tfs</td></tr><tr><td>AZP_TOKEN</td><td>是</td><td>前面申请的有足够权限的Personal Access Token</td></tr><tr><td>AZP_AGENT_NAME</td><td>是</td><td>显示在Agent Pool中的Agent名字</td></tr><tr><td>AZP_POOL</td><td>是</td><td>Agent pool的名字</td></tr><tr><td>AZP_AGENTPACKAGE_URL</td><td>否</td><td>显式指定Azure Agent包的下载地址</td></tr></tbody></table><p>变量“AZP_AGENTPACKAGE_URL”的额外说明：<br>从容器的启动脚本“start.sh”中可以看出，容器在启动时会去某个网址上下载Azure Agent包。如果发现下载比较慢或者根本没法下载导致容器启动慢或者失败，可以提前这个包下载下来并放在内部的某个http服务器上，然后通过变量“AZP_AGENTPACKAGE_URL”把这个http链接地址传进去。</p><p>通过执行“start.sh”中的shell命令可以获得Azure Agent包的地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -LsS \<br>  -u user:&lt;your-azure-devops-pat&gt; \<br>  -H <span class="hljs-string">&#x27;Accept:application/json;api-version=3.0-preview&#x27;</span> \<br>  <span class="hljs-string">&quot;&lt;your-azure-devops-url&gt;/_apis/distributedtask/packages/agent?platform=linux-x64&quot;</span><br></code></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>利用Azure DevOps agent去执行Jenkins Job时经常会遇到下面的问题：</p><p>getaddrinfo ENOTFOUND …</p><p>解决办法是在启动容器时通过参数“–add-host”将Jenkins Server的域名和IP映射关系加到&#x2F;etc&#x2F;hosts中。具体如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -it -d --name some-agent \<br>        --add-host &lt;your jenkins server domain name&gt;:&lt;you jenkins server ip address&gt;<br>        -e AZP_URL=your-azure-devops-url \<br>        -e AZP_TOKEN=your-azure-devops-pat \<br>        -e AZP_AGENT_NAME=some-agent \<br>        -e AZP_POOL=your-azure-devops-agent-pool \<br>        -e AZP_AGENTPACKAGE_URL=the-zure-devops-agent-package \<br>        azure-agent:&lt;tag&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Azure DevOps</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是GitOps?</title>
    <link href="/2019/07/21/gitops/"/>
    <url>/2019/07/21/gitops/</url>
    
    <content type="html"><![CDATA[<p>[原文] <a href="https://www.weave.works/technologies/gitops/">https://www.weave.works/technologies/gitops/</a></p><p>您是否听说过GitOps并且也想知道它到底是什么？ 本文，我们将介绍GitOps工作流的原理和模式，以及如何实现它们以便在生产环境中规模化运行Kubernetes。 我们还将描述GitOps与基础架构代码（IAC)，配置管理工具之间的差异，当然还将向您展示如何将GitOps最佳实践作为您自己的开发环境的一部分。</p><span id="more"></span><h1 id="GitOps是什么"><a href="#GitOps是什么" class="headerlink" title="GitOps是什么?"></a>GitOps是什么?</h1><p><img src="/2019/07/21/gitops/1.png"></p><p><strong>GitOps</strong> Kubernetes集群管理和应用程序交付的一种方法。它是用Git作为声明式基础架构和应用程序的单一事实来源。通过将Git作为交付管道的中心，开发可以通过拉取请求(Pull Request)来加速和简化Kubernetes应用程序的部署和运维任务。</p><p><strong>一种构建云原生应用的操作模式</strong></p><p>GitOps可以概括为以下两点:</p><ol><li>Kubernetes和其它云原生技术的一种操作模式，提供一组统一部署，管理和监控容器化集群和应用程序的最佳实践。</li><li>面向开发者的管理应用程序的经验，将端到端的CI&#x2F;CD管道和Git工作流应用于运维和开发。</li></ol><h1 id="GitOps的主要优点"><a href="#GitOps的主要优点" class="headerlink" title="GitOps的主要优点"></a>GitOps的主要优点</h1><p>当Git中有变更发生时，自动化交付管道会自动变更你的基础架构。然而GitOps概念远不止于此 - 它使用工具将整个应用程序的实际生产状态与源码管理工具中的代码进行比较，当你的集群与实际状态不符时，给出提醒。</p><p>通过应用GitOps最佳实践，你的基础架构和应用程序会有一个“事实来源”，这将提高开发团队的速度并提高系统可靠性。</p><p>采用GitOps最佳实践的好处是深远的，并提供：</p><ol><li><p><strong>提高生产力</strong><br>自动化的持续部署加上集成的反馈控制回路提升了平均部署时间。你的团队每天能够提交30到100倍的更多变更，将总体开发输出提高2到3倍。</p></li><li><p><strong>增强开发体验</strong><br>推送代码而不是容器。开发不需要深入了解Kubernetes就可以使用熟悉的工具(比如Git)快速地更新Kubernetes应用和添加新的功能。新入职的开发能够在几天内而不是几个月内快速地提升开发效率。</p></li><li><p><strong>提高稳定性</strong><br>当你使用Git工作流管理你的集群时，你不需要通过Kubernetes就能够自动获取便于审核的集群的所有变更日志。通过审核跟踪谁在何时变更了你的集群能够满足SOC 2合规性并能确保稳定性。 </p></li><li><p><strong>高可用性</strong><br>借助Git恢复&#x2F;回滚和分叉功能，你将获得稳定并可重复的回滚功能。因为你通过Git描述了整个系统，你将有一个单一的事实来源用来从崩溃中恢复，从而将你的恢复时间(MTTR)从几小时降到几分钟。</p></li><li><p><strong>一致性和标准化</strong><br>由于GitOps提供了统一的模型用来变更基础架构，应用以及Kubernetes add-on，你可以在整个组织中实现一致的端到端的工作流。不仅你的持续集成和持续交付管道通过拉取请求(Pull Request)驱动，你的操作任务通过Git也完全可以重现。</p></li><li><p><strong>更健壮的安全保证</strong><br>Git的强正确性以及安全保证(背后是健壮的用于追踪和管理变更的加密技术)，以及签名变更以证明作者身份和来源的能力是安全定义集群目标状态的关键。</p></li></ol><h1 id="GitOps是满足云原生的持续交付"><a href="#GitOps是满足云原生的持续交付" class="headerlink" title="GitOps是满足云原生的持续交付"></a>GitOps是满足云原生的持续交付</h1><p>GitOps是从DevOpsSite Reliability Engineering(站点可靠性工程)的想法中逐渐演变出来的，这些想法始于<a href="https://martinfowler.com/articles/continuousIntegration.html">2016念Martin Fowler对持续集成的全面概述</a></p><h2 id="自由选择所需的工具"><a href="#自由选择所需的工具" class="headerlink" title="自由选择所需的工具"></a>自由选择所需的工具</h2><p>作为CI&#x2F;CD管道的一个工作流，GitOps被<a href="https://martinfowler.com/articles/continuousIntegration.html">描述为开发过程的圣杯</a>。由于没有单一的工具能够完成CI&#x2F;CD管道中所有的工作，GitOps可以让你为每个部分选择最佳的工具。你可以从开源生态系统选择一组工具，也可以从闭源中选择一组工具，你甚至可以根据你的具体情况，组合使用它们。创建CI&#x2F;CD管道最困难的部分是将所有的工具组合在一起。</p><p>无论你选择什么工具来构建交付管道，通过Git(或任何版本管理系统)应用GitOps的最佳实践都应该是你流程中不可或缺的组成部分。这样做可以轻松地过渡到持续交付。不论是从技术角度还是从文化角度都应该如此。</p><h1 id="GitOps的原则"><a href="#GitOps的原则" class="headerlink" title="GitOps的原则"></a>GitOps的原则</h1><p>开始使用GitOps工作流管理你的集群，必须具备以下条件：</p><p><strong>1. 整个系统以声明方式描述</strong><br>Kubernetes只是众多现代云原生工具的一个例子，它们是可“声明的”，可以被视为代码。可声明意味着配置是由一组事实而不是一组指令来保证的。将你的应用的声明版本管理到Git，你只有一个事实来源。你可以轻松地部署和回滚Kubernetes的应用。更重要的是，当灾难发生时，你可以快速可靠地重现集群的基础架构。</p><p><strong>2. 在Git中管理规范的目标系统状态版本</strong><br>通过将你系统的声明存储在版本管理系统中，并作为你的规范性事实来源，你可以从一个地方获取和驱动所有的内容。这简化了回滚操作，你可以使用“Git Revert”来回滚到之前的应用程序状态。借助Git出色的安全保障，你可以使用SSH密钥对提交进行签名，从而对代码的作者和来源实施强有力的安全保障。 </p><p><strong>3. 批准的更改可以自动应用于系统</strong><br>一旦将声明的状态保存在Git中，下一步就是允许对该状态的任何更改都能够被自动应用于你的系统。有意义的是，你不需要集群的账号来更改你的系统。借助于GitOps，状态定义存在于这个隔离环境之外。这使你可以解耦做什么与如何做。</p><p><strong>4. 软件代理确保差异的正确性并报警</strong><br>一旦你的系统状态被声明并保存在版本控制系统中，每当实际状态与期望状态不符，软件代理就可以通知你。代理的使用还可以确保你的整个系统是自修复的。通过自修复，不仅仅是指节点或pod失败时(Kubernetes会处理这类失败)，而是在更广泛的意义上，比如人为错误的情况。在这种情况下，软件代理充当了你的操作的反馈和控制闭环。</p><h1 id="Git赋能基础架构即代码-IAC-工具"><a href="#Git赋能基础架构即代码-IAC-工具" class="headerlink" title="Git赋能基础架构即代码(IAC)工具"></a>Git赋能基础架构即代码(IAC)工具</h1><p>Kubernetes只是众多现代云原生工具的一个例子，它们是可“声明的”，可以被视为代码。可声明意味着配置是由一组事实而不是一组指令来保证的。例如，“有十个redis服务器”，而不是“启动十个redis服务器”，并且提示我可行。</p><p>借助声明式工具，你的整个配置文件可以在Git中进行版本管理。通过使用Git作为事实来源，你可以轻松地部署和回滚Kubernetes的应用。更重要的是，当灾难发生时，你可以从Git中快速可靠地重现集群的基础架构。</p><h2 id="IAC工具-vs-GitOps"><a href="#IAC工具-vs-GitOps" class="headerlink" title="IAC工具 vs. GitOps"></a>IAC工具 vs. GitOps</h2><p>作为能够按要求创建服务器的基础架构即代码工具已经存在相当长的一段时间了。这些工具产生了保持基础架构及代码配置版本化，可备份化以及可重现的概念。</p><p>但是现在由于Kubernetes几乎完全是声明性的，结合不可变容器，可以将这些概念中的一些扩展到管理应用程序及其操作系统。</p><p>能够管理和比较基础架构和应用程序的当前状态，以便借助使用Git完整的审计跟踪，你能测试，部署，回滚和前滚，这是GitOps理念及其最佳实践内容。这是可行的，因为Kubernetes几乎完全通过声明性配置进行管理，以及容器也是不可变的。</p><p>在Weaveworks，我们使用Terraform和Ansible来创建服务器。我们将那些配置文件保存在Git中进行版本管理。IAC工具及其相关的配置文件构成了我们GitOps工作流的核心部分，如果发生灾难，可以做到近乎实时的集群恢复。通过<a href="http://www.weave.works/technologies/gitops-frequently-asked-questions">GitOps FAQ</a>了解更多的基础架构及代码与GitOps的区别。</p><h2 id="我的系统与事实来源出现差异该如何？"><a href="#我的系统与事实来源出现差异该如何？" class="headerlink" title="我的系统与事实来源出现差异该如何？"></a>我的系统与事实来源出现差异该如何？</h2><p>声明式工具允许你在Git中描述期望的真实状态。但是在实际系统中的真实状态可能会有问题，这可能与版本管理系统中描述的状态有差别。</p><ul><li>你如何知道实际系统达到了期望状态？  </li><li>当有差异时，你能得到通知吗？  </li><li>有什么机制类似于“煤矿中的金丝雀”在你遇到麻烦时通知你？</li><li>你如何触发集群与版本管理系统之前的同步？</li></ul><p>这里有现成的技术.</p><p>IAC工具，比如Chef，Puppet和Ansible支持“差异警告”功能。这有助于运维人员知道何时应该采取行动将实际系统收敛到期望状态（通过配置脚本定义的）。甚至最近，最佳实践是部署不可变镜像（比如容器），以便尽可能减少差异。</p><p>在“GitOps”模型中，在一组用来比较期望状态和实际状态的“比较”和“同步”工具（<a href="https://github.com/weaveworks/kubediff">kubediff</a>, 以及 terradiff 和ansiblediff）的辅助下，我们使用Git解决差异和收敛。</p><h2 id="GitOps构建在不可变基础架构之上"><a href="#GitOps构建在不可变基础架构之上" class="headerlink" title="GitOps构建在不可变基础架构之上"></a>GitOps构建在不可变基础架构之上</h2><p>GitOps充分利用不断发展的不可变基础架构和声明式容器编排。在Weaveworks，我们一天部署多次。为了降低部署后变更的风险，无论是有意的还是偶然的“配置偏差”，我们必须维护一个可重现且可靠的部署过程。</p><p>我们整个系统的期望状态（也就是“事实来源”）是在Git中描述的。我们使用容器实现不可变性，以及Terraform和Ansible等不同的云原生工具来自动化和管理我们的配置。这些工具与容器以及Kubernetes声明性的本质一起提供了在发生灾难时完整恢复所需要的东西。</p><h2 id="与IAC工具协作"><a href="#与IAC工具协作" class="headerlink" title="与IAC工具协作"></a>与IAC工具协作</h2><p>当你将GitOps原则应用于“所有方面”时，除了报警规则和仪表盘之外包括机器配置，应用程序和服务，所有这些都保存在版本管理系统中。</p><p>除非通过Git，否则不需要访问正在运行的系统。任何一组更改都可以是原子性的，并且能够做相应地比较。Git记录也不仅仅是审计日志，还是可用于在任何快照之前来回滚动的事物日志。</p><h1 id="Weave-Cloud的持续交付和GitOps工作流"><a href="#Weave-Cloud的持续交付和GitOps工作流" class="headerlink" title="Weave Cloud的持续交付和GitOps工作流"></a>Weave Cloud的持续交付和GitOps工作流</h1><p>在我们的产品<a href="https://cloud.weave.works/signup">Weave Cloud</a>中, GitOps的核心机制已经内置于CI&#x2F;CD的工具中了，关键部分是持续部署(CD)，<a href="https://github.com/weaveworks/flux/blob/master/site/introduction.md#automated-git-cluster-synchronisation">支持Git-cluster同步</a>。</p><p>Weave Cloud是专门为版本控制系统和声明式应用程序栈设计的。团队中的每个开发人员都可能熟悉Git且能够创建拉取请求(Pull Request)。现在，他们也能够使用Git加速并简化Kubernetes应用的部署。</p><p>以下是以典型的创建和更新一个新功能的开发流程：</p><ol><li>推送一个新功能的拉取请求(Pull Request)到GitHub进行审核。</li><li>代码被同事审核并批准后，被合并到Git。</li><li>Git合并触发CI流水线，通过一系列测试后，新构建出来的镜像被存储到镜像仓库里。</li><li>Weave Cloud的“Deployment Automator” 检测到镜像仓库中有新的镜像，从仓库中拉取新的镜像并跟新配置仓库中的YAML文件。</li><li>Weave Cloud的“Deployment Synchronizer” (运行在集群中)，检测到集群有更新，它从配置仓库中拉取变更后的清单并将新的功能部署到生产环境中。</li></ol><p><strong>支持GitOps的CI&#x2F;CD管道：</strong></p><p><img src="/2019/07/21/gitops/1.png"></p><h2 id="使用Operator模式实现的Kubernetes控制器"><a href="#使用Operator模式实现的Kubernetes控制器" class="headerlink" title="使用Operator模式实现的Kubernetes控制器"></a>使用Operator模式实现的Kubernetes控制器</h2><p>Weave Cloud实现了以自定义的控制器用来监听和同步你的Kubernetes集群。控制器是使用Operator模式实现的，有两个层面的意义：首先，它更安全；其次，它能够自动处理复杂的易错的任务，比如必须手动更新YAML清单。</p><p>通过使用Operator模式，代理会代表集群监控自定义资源变更事件，以便部署这些变更。代理负责同步Git与集群，并且为你的团队提供了一种实现持续部署的简单方法。</p><h2 id="拉-vs-推管道"><a href="#拉-vs-推管道" class="headerlink" title="拉 vs 推管道"></a>拉 vs 推管道</h2><p><strong>推管道</strong><br>目前大部分CI&#x2F;CD工具使用推模型。基于推模型的管道意味着代码从CI系统开始，通过一系列的脚本或者手动使用“kubectl”将变更推到Kubernetes集群。</p><p>你不希望使用CI系统触发部署或者通过命令行手动部署，原因是可能在集群之外泄露账号。虽然可以保护你的CI&#x2F;CD脚本和命令行，但你是在集群信任域之外工作。这通常不是好的做法，这也是为什么CI系统能被为生产环境攻击的载体。</p><p>具有集群外部读&#x2F;写权限的推式的管道：<br><img src="/2019/07/21/gitops/2.png"></p><p>在Weave Cloud中，在集群内部保存账号并拉取镜像：<br><img src="/2019/07/21/gitops/3.png"></p><p><strong>Weave Cloud拉管道</strong><br>Weave Cloud使用由两个关键组件组成的拉取策略：一个是监测镜像仓库的”Deployment Automator”和一个集群中以维持其状态的”Deployment Synchronizer”。</p><p>在我们拉取管道模式的中心是清单（或配置仓库）的单一事实来源。开发将他们的更新代码推送到代码仓库，CI工具获取更改并最终构建出Docker镜像。Weave Cloud的“Deployment Automator”检测到新的镜像，从镜像仓库中拉取新的镜像并更新配置仓库中的YAML配置。“Deployment Synchronizer”检测到集群已经过期，并从配置仓库中拉取更改的清单，并将新的镜像部署到集群。</p><p><strong>安装在集群中的Weave Cloud部署代理</strong><br>使用群集内部的Deployment Synchronizer，你的群集账号不会在生产环境之外公开。 一旦Weave Cloud代理安装到你的集群并且与你的Git仓库已连接，你的生产环境中的任何更改都将通过具有完全回滚的Git拉请求(Pull Request)以及Git提供的方便审计日志完成。<br><img src="/2019/07/21/gitops/4.png"></p><p><strong>可观察性是部署的催化剂</strong><br>通过Kubernetes，GitOps可以通过拉取请求(Pull Request)管理基础架构和应用程序。但是GitOps工作流和可观察性如何协同工作？</p><p>通过GitOps工作流和实时可观察性，你的开发团队可以在部署任何新功能之前做出关键决策。由于在发布之前你可以在正在运行的集群中实时观察即将发布的服务，这意味着你能够自信，快速地部署并交付更高质量的功能。</p><p>可观察性可以被视为Kubernetes<a href="https://continuousdelivery.com/">持续交付</a>周期的主要驱动因素之一，因为它描述了任何给定时间的系统实际运行状态。观察运行系统以便理解和控制它。新功能和修复被推送到Git并触发部署管道，何时准备发布可以通过实时观察正在运行的集群。此时，根据此反馈，开发人员可以返回到管道的开始，或者部署并发布到产品集群中。</p><p>GitOps是面向发布的操作和功能模型。你向客户交付新功能的速度有多快，部分取决你的团队在此周期中通过各阶段的速度。<br><img src="/2019/07/21/gitops/5.png"></p><p>使用GitOps工作流和可观察性的开发人员需要回答这些问题：</p><ol><li>如果自动发布一个变更，我们如何知道它确实有效？</li><li>如何确定我们的变更实际是在驱动改进？</li><li>在复杂的分布式系统中，我们如何理解，诊断问题并处理事件？</li></ol><p>通过Weave Cloud，可观察工作负载仪表盘已集成到部署和发布流程中。在承诺将部署发布到准备环境或生产环境之前，你可以看到部署是否成功。这不仅帮助你更快地识别问题，而且由于可观察性工作负载仪表盘是实时的并且内置于部署过程中，你可以自信的一天多次地部署你的服务并确信部署没有重大缺陷。<br><img src="/2019/07/21/gitops/6.png"></p><h1 id="GitOps的优点"><a href="#GitOps的优点" class="headerlink" title="GitOps的优点"></a>GitOps的优点</h1><p><strong>更快的部署</strong><br>通过采用GitOps的最佳实践，开发人员可以使用熟悉的工具比如Git来快速地管理Kubernetes应用的更新和新功能。通过持续的推送功能更新，企业变得更加敏捷，能够更快地反应客户需求，并在市场中更具竞争力。</p><p><strong>更好的操作</strong><br>使用GitOps，你拥有一个完整的端到端的管道。不仅你的持续集成和持续交付管道都是由拉取请求(Pull Request)驱动，而且你的操作任务也可以通过Git完全重现。</p><p>如果你正在使用Weave Cloud，可以安全地部署到正在运行的集群中，不会将敏感的账号泄露在集群之外。</p><p><strong>更健壮的安全保证</strong><br>Git的强正确性以及安全保证(背后是健壮的用于追踪和管理变更的加密技术)，以及对变更的签名从而证明作者身份和来源的能力是正确和安全地定义集群目标状态的关键。如果发生安全漏洞，可以独立于脆弱的系统使用不可变和可审计的事实来源重新创建新的系统，从而减少停机时间并允许更好的事件响应。</p><p>打包软件和发布到生产环境的职责分离也体现了最小特权的安全原则，减少脆弱影响并提供了更小的攻击面。</p><p><strong>使得合规和审核更容易</strong><br>由于以安全的方式追踪和和记录更改，因此合规性和审计变得微不足道。使用kubediff，terradiff和ansiblediff可以将集群的可信任状态定义与实际运行的集群进行比较，从而确保可追踪和审核的变更与实际相符。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>GitOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins Job的并发执行</title>
    <link href="/2019/07/08/jenkins-concurrent-builds/"/>
    <url>/2019/07/08/jenkins-concurrent-builds/</url>
    
    <content type="html"><![CDATA[<p>并发，多线程是程序设计领域老生常谈的问题，唯一的目的就是提高程序的执行效率-充分利用资源更快地处理多个计算请求。在持续集成、交付(CI&#x2F;CD)领域同样存在着并发执行的需求。本文将主要介绍Jenkins Job的并发执行以及相关问题的探讨。<span id="more"></span>其实不仅是Jenkins，任何一个持续集成(CI)服务器都应该支持CI Job的并发执行，其原因有以下两点：</p><ul><li>充分利用Slave资源。如果让一台VM Slave一次只处理一个CI请求，往往会浪费很多的资源（CPU，Memory，Storage）。</li><li>持续集成的最佳实践要求快速地“Build Per Change Commit”，但是对于一些比较耗时的持续集成流水线，比如项目比较大，或者自动化测试的时间比较长，往往是前一个集成还没结束，新的change commit已经到来，如果不能并发执行，只能阻塞等待，导致commit的提交者不能及时得到反馈，从而使持续集成流水线在项目中失去了应有的作用，地位也会变得比较尴尬。此时，如果再一味地推进与持续集成流水线配套的一些策略，将会受到很大的阻力。</li></ul><h1 id="Jenkins-Job缺省的并发行为"><a href="#Jenkins-Job缺省的并发行为" class="headerlink" title="Jenkins Job缺省的并发行为"></a>Jenkins Job缺省的并发行为</h1><p>随着Jenkins Pipeline2.0的引入，目前主要有三种类型的Jenkins Job：Free Style Job，Scripted Pipeline and Declarative Pipeline。Scripted Pipeline and Declarative Pipeline属于Jenkins Pipeline2.0引入的Job类型，最大的优点就是Pipeline as Code，在一个Jenkinsfile文件里可以编写整个CI流程，并且可以提交到代码仓库，比如Git，作版本管理。由于Pipeline2.0突出的优点，目前越来越多的公司和组织开始使用它来构建持续集成和持续交付流水线，但是Free Style类型的Job目前还是主要支持的Job类型之一，没有被废弃掉，其原因可能有两个：<br>1，并不是所有的插件都能够很好地支持Pipeline2.0（下一节的Throttle Concurrent Builds Plugin就是个例子）；<br>2，不少公司或组织还有很多遗留的Free Style类型的Job，所以本文仍然会涉及这三个类型的Job。</p><p>为了支持Jenkins Job并发执行，首先需要设置Jenkins Slave的Build Executors的数量大于1：<br><img src="/2019/07/08/jenkins-concurrent-builds/1.png"></p><p>当Jenkins Job有新的build请求时，只要匹配的Slave节点有空闲的Executor，即使已经有build在执行，新的build也会立刻被并发执行。如果匹配的Slave节点没有空闲的Executor，这个新的build请求将被放入待执行队列里等待调度。</p><p>Free Style Job缺省并没有打开并发执行的功能。需要在Job的配置中打开选项“Execute concurrent builds if necessary”：<br><img src="/2019/07/08/jenkins-concurrent-builds/2.png"></p><p>Pipeline2.0的Job缺省是并发执行模式。如果要禁止并发执行，可以通过添加以下代码：</p><ul><li><p>Scripted Pipeline</p><p>在Jenkinsfile头部添加以下属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsl">properties(<br>  [<br>      disableConcurrentBuilds()<br>  ]<br>)<br></code></pre></td></tr></table></figure></li><li><p>Declarative Pipeline</p><p>在pipeline块中添加以下选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsl">pipeline &#123;<br>    options &#123;<br>        disableConcurrentBuilds()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="Jenkins-Job并发执行需要解决的问题"><a href="#Jenkins-Job并发执行需要解决的问题" class="headerlink" title="Jenkins Job并发执行需要解决的问题"></a>Jenkins Job并发执行需要解决的问题</h1><p>Jenkins Job的并发执行是一把双刃剑，用得好，所向披靡，能够充分利用既有资源服务更多的持续集成请求，用得不好，会出现很多预料不到的问题，而且有些问题并不能重复出现，给调试带来了很大的负担。Jenkins Job的并发执行主要面临的问题是资源使用的冲突。下图是一个常见的基于Pipeline2.0实现的一个Jenkins CI Job(yunzai-ci)：<br><img src="/2019/07/08/jenkins-concurrent-builds/3.png">按照流程顺序，逐一分析如下：</p><ul><li><p>在“Checkout Code”阶段，同一个Jenkins Job并发执行的build在同一个Slave上的Workspace会存在着冲突。对于这个问题，其实Jenkins已经提供了解决方案，细心的你一定会发现在Slave机子上同一个Job会存在着多个文件夹，比如“yunzai-ci”，“yunzai-ci@1”，“yunzai-ci@2”…，这就是同一个Job并发执行的build对应的不同的Workspace。Jenkins缺省是在Job的名字后面加上符号@和数字来命名不同的Workspace的，当并发执行的build数量大于Workspace的数量，Jenkins会根据命名规则自动创建一个新的Workspace，当并发执行的build数量小于Workspace数量，Jenkins会按顺序重用已有的Workspace。</p><blockquote><p>Workspace的分隔符@可以在启动Jenkins master时设置Java系统属性“hudson.slaves.WorkspaceList”来改变。比如，“hudson.slaves.WorkspaceList&#x3D;-”将Workspace的分隔符改为中划线。</p></blockquote><p>Workspace的冲突解决了，但是又引入了一个潜在的效率问题。想象一下，如果项目的代码库比较大(几百兆，或者几个G)，那么在创建一个新的Workspace时，会重新从远处的代码仓库克隆代码，这将导致当前Jenkins job执行的时间被拉长。可以优化Jenkins Job，通过拷贝本地已有Workspace的代码来提升速度(Linux上可以使用Rsync，Window上可以使用Robocopy)，而不是直接从远程代码仓库去克隆代码。</p></li><li><p>在“Build&#x2F;UT”阶段，会使用不同的自动构建工具和包管理工具，比如Maven, Gradle, Npm, Bower等等，构建出来的制品会上传到制品仓库(Artifactory或Nexus)。这里，自动构建工具的本地缓存，以及构建制品上传到制品仓库都可能存在冲突。比如Maven, 缺省的本地缓存是在当前用户的.m2目录下，Maven执行时会更新或者下载项目的依赖到本地缓存，或者安装当前构建的制品到本地缓存，当同一个Jenkins Job并发执行的build运行在同一个Jenkins Slave上时，会启动多个Maven进程同时执行，它们会下载同一个依赖包或者安装相同版本(Maven的snapshot版本或者其它原因导致两个build版本相同)的构建制品到到同一个缓存目录，这时就会经常出现写磁盘文件冲突的问题，而且这个问题不是每次都发生。当多个Maven进程同时上传相同版本的制品到制品仓库时，也会存在着冲突。<br>要解决这类型的冲突，需要具体情况，具体对待。对于Maven来说，可以通过属性”maven.repo.local”来为每个Maven进程指定不同的本地缓存目录，且保证每个Build的版本都是唯一的。这个解决方案同样存在着效率问题，每开一个新的Maven本地缓存目录都会增加build的执行时间，因为Maven要重新去下载项目的所有依赖，这时也可以通过拷贝本地已有的缓存目录来提升速度。</p></li><li><p>在“Code Static Check”阶段，如果使用的是SonarQube，则不会产生冲突，因为每一个并发执行的build都会在SonarQube服务端产生一个独立的分析，所以不会相互干扰。但如果是其它的静态代码分析服务器，可能就需要具体情况，具体对待。</p></li><li><p>在“自动化测试”阶段，由于资源有限(自动化测试机器有限，而且执行自动化测试用例也需要一定的时间)，所以不一定能够服务于并发执行的多个build。这时可以增加自动化测试机器(虚拟机)，同时进行测试分级，抽取出部分重要的测试用例放到Jenkins Job中去执行以降低测试执行的时间。可以把全量测试降级为以天为单位，比如每晚取最新的build去执行全量测试，并给出测试报告。</p></li></ul><p>不同公司或组织的持续集成流水线可能和上文描述的不相同，为了能够并发执行Jenkins Job，需要逐一分析和解决每个阶段可能出现的资源冲突问题。</p><h1 id="Jenkins-Job并发执行的精确控制-Throttle-Concurrent-Builds-Plugin"><a href="#Jenkins-Job并发执行的精确控制-Throttle-Concurrent-Builds-Plugin" class="headerlink" title="Jenkins Job并发执行的精确控制(Throttle Concurrent Builds Plugin)"></a>Jenkins Job并发执行的精确控制(Throttle Concurrent Builds Plugin)</h1><p>Jenkins Job缺省的并发行为是只要有足够可用的Jenkins Slave和Executor资源，启动的build数量是不限的。但实际情况是我们需要精确地控制某个Jenkins Job总的并发执行的build数量，同时也希望单个Jenkins Slave节点上同一个Jenkins Job并发执行的build数量，这样可以限制某个Jenkins Job的总体资源消耗，保证其它Jenkins Job也能均衡执行。借助于Jenkins插件“Throttle Concurrent Builds Plugin”可以达到这样的控制目的。“Throttle Concurrent Builds Plugin”支持系统级别的配置，也支持Job级别的配置：</p><ul><li><p>系统级别的配置：<br><img src="/2019/07/08/jenkins-concurrent-builds/4.png">系统级别的配置可以设置一个并发执行的类别，不同的Jenkins Job可以引用这个类别。<br>“Maximum Total Courrent Builds”用来设置Jenkins Job最大的并发数量。<br>“Maximum Concurrent Builds Per Node”用来设置同一个Jenkins Job在同一个Slave节点上最大的并发数量。</p></li><li><p>Free Style Job级别的配置：<br><img src="/2019/07/08/jenkins-concurrent-builds/5.png">在Job级别，可以选择“Throttle this project alone”，并且设置“Maximum Total Courrent Builds”和“Maximum Concurrent Builds Per Node”这两个值，也可以通过“Multi-Project Throttle Category”选择系统级别配置好的并发执行的类别。</p></li><li><p>Scripted Pipeline只支持使用系统级别配置好的并发执行类别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dsl">throttle([&#x27;test-cocurrent&#x27;]) &#123;<br>  node(&#x27;xxxx&#x27;) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于Declarative Pipeline，目前“Throttle Concurrent Builds Plugin”还不支持，所以只能是前面讨论的缺省并发行为。</p><blockquote><p>对于插件“Throttle Concurrent Builds Plugin”的详细用法，<br>可以参考插件的Wiki: <a href="https://wiki.jenkins.io/display/JENKINS/Throttle+Concurrent+Builds">https://wiki.jenkins.io/display/JENKINS/Throttle+Concurrent+Builds+Plugin</a>和GitHub地址: <a href="https://github.com/jenkinsci/throttle-concurrent-builds-plugin">https://github.com/jenkinsci/throttle-concurrent-builds-plugin</a>。</p></blockquote></li></ul><h1 id="Jenkins-Job相同参数build的执行情况"><a href="#Jenkins-Job相同参数build的执行情况" class="headerlink" title="Jenkins Job相同参数build的执行情况"></a>Jenkins Job相同参数build的执行情况</h1><p>所谓相同参数build，就是指同一个Jenkins Job以相同的参数触发多个build。不论是Jenkins Job并发执行，还是非并发执行，只要有符合Jenkins Job执行的Slave和Executor资源而且并发策略允许，所有被触发的build都会被立刻执行。但如果没有足够的执行资源，或者并发策略不允许，而且已经有build在待执行队列里等待的情况下，再次触发与等待的build参数相同的build，行为就会有些区别，总结如下：</p><table><thead><tr><th>Job类型</th><th>并发执行</th><th>非并发执行</th></tr></thead><tbody><tr><td>Free Style Job</td><td>相同参数的build只会加入到待执行队列一次</td><td>相同参数的build只会加入到待执行队列一次</td></tr><tr><td>Scripted Pipeline</td><td>相同参数的build会重复加入到待执行队列</td><td>相同参数的build只会加入到待执行队列一次</td></tr><tr><td>Declarative Pipeline</td><td>相同参数的build会重复加入到待执行队列</td><td>相同参数的build只会加入到待执行队列一次</td></tr></tbody></table><p>以上是根据实测得到的结果，并没有任何官方文档提供详细的说明，所以随着Jenkins版本的升级，其行为有可能会变化。</p><h1 id="容器作为Slave节点会让并发执行变得容易吗？"><a href="#容器作为Slave节点会让并发执行变得容易吗？" class="headerlink" title="容器作为Slave节点会让并发执行变得容易吗？"></a>容器作为Slave节点会让并发执行变得容易吗？</h1><p>最近几年容器技术借助于Docker在IT领域里掀起了巨大的变革，容器编排平台Kubernetes的出现更是将容器化的应用推向高潮。在CI&#x2F;CD领域也不例外，越来越多的组织开始尝试利用Docker容器作为CI Job执行的Slave节点，通过Kubernetes平台统一管理调度虚拟机资源，以期望更加细粒度地控制和使用计算资源。Docker容器作为Slave节点确实是实现了本地执行环境的隔离，但每次执行都会启动全新的容器，都得重新下载代码和构建工具的本地缓存，使得每次的构建都要花费更长的时间，所以还是要考虑如何提升效率。</p>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建自签名TLS/SSL证书和私钥</title>
    <link href="/2018/12/30/create-self-signed-ssl/"/>
    <url>/2018/12/30/create-self-signed-ssl/</url>
    
    <content type="html"><![CDATA[<p>TLS(Transport Layer Security)-传输层安全协议，及其前身SSL(Secure Sockets Layer)-安全套接层是一种安全协议，在传输层对网络连接进行加密。TLS协议由两层组成：TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面，与具体的应用无关，所以，一般把TLS协议归为传输层安全协议。TLS握手协议使用该层中的公钥和证书来处理对等用户的认证，以及协商算法和加密实际数据传输的私钥。这个过程是在TLS记录协议的顶部执行的。TLS所采用的证书系统可以确保客户端与服务端传输的数据是被加密的，且服务端是被受信任的，但是前提是TLS所采用的证书是由信任的证书颁发机构(CA)颁发的。基于测试或内部使用的目的，本文将介绍如何创建自签名的TLS&#x2F;SSL证书，如何配置Nginx使用这个自签名证书和私钥，以及如何在Linux, Windows和Mac客户端安装这个证书。需要说明的是自签名证书无法确认服务端是被受信任的。</p><span id="more"></span><h1 id="生成自签名证书和私钥"><a href="#生成自签名证书和私钥" class="headerlink" title="生成自签名证书和私钥"></a>生成自签名证书和私钥</h1><blockquote><p>本文是在Ubuntu 16.04系统上调用openssl工具生成自签名证书和私钥。</p></blockquote><p>使用openssl命令生成自签名证书和私钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout selfsigned-key.key -out selfsigned-certificate.crt<br></code></pre></td></tr></table></figure><ul><li>openssl: 基本命令行工具，用来创建和管理OpenSSL证书，私钥和其它文件。</li><li>req: 子命令，主要是用来创建和处理PKCS#10格式的证书请求。它也能创建被用作根证书的自签名证书。</li><li>-x509: 这个选项告诉openssl创建一个自签名证书而不是一个证书请求。</li><li>-nodes: 这个选项告诉openssl不要加密私钥，否则当使用在Nginx上时，每次Nginx启动都要提示输入密码。</li><li>-days 365: 设置证书的有效期为1年（365天）。</li><li>-newkey rsa:2048: 这个选项告诉openssl在生成证书的同时生成私钥。rsa:2048说明创建一个2048比特长的RSA私钥。</li><li>-keyout: 告诉openssl生成的私钥的名字和路径。</li><li>-out: 告诉openssl生成的自签名证书和路径。</li></ul><p>命令会提示以下的一些输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Country Name (2 letter code) [AU]:CN<br>State or Province Name (full name) [Some-State]:Shanghai<br>Locality Name (eg, city) []:Shanghai<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:&lt;The company name&gt;<br>Organizational Unit Name (eg, section) []:&lt;The unit name of company&gt;<br>Common Name (e.g. server FQDN or YOUR name) []:&lt;Domain name or Server IP address&gt;<br>Email Address []:&lt;xxxx@xxx.xxx&gt;<br></code></pre></td></tr></table></figure><h1 id="配置Nginx使用自签名证书和私钥"><a href="#配置Nginx使用自签名证书和私钥" class="headerlink" title="配置Nginx使用自签名证书和私钥"></a>配置Nginx使用自签名证书和私钥</h1><ol><li><p>将证书和私钥放在Nginx服务器上某个路径下，比如”&#x2F;etc&#x2F;nginx&#x2F;ssl-certs”；</p></li><li><p>编辑”&#x2F;etc&#x2F;nginx&#x2F;sites-enabled”下的配置文件“*.conf”，在头部(server节点之外)加上以下两行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssl_certificate       /etc/nginx/ssl-certs/selfsigned-certificate.crt;<br>ssl_certificate_key   /etc/nginx/ssl-certs/selfsigned-key.key;<br></code></pre></td></tr></table></figure></li><li><p>重新加载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -s reload<br></code></pre></td></tr></table></figure></li><li><p>重启Nginx服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart nginx<br></code></pre></td></tr></table></figure></li></ol><h1 id="在客户端安装自签名证书"><a href="#在客户端安装自签名证书" class="headerlink" title="在客户端安装自签名证书"></a>在客户端安装自签名证书</h1><blockquote><p>当自签名证书安装完后，不同的客户端程序为了能够识别和使用这个证书可能需要做不同的操作，比如docker客户端需要重新启动。</p></blockquote><h2 id="Linux客户端"><a href="#Linux客户端" class="headerlink" title="Linux客户端"></a>Linux客户端</h2><h3 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu, Debian"></a>Ubuntu, Debian</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><ol><li><p>将证书拷贝到目录“&#x2F;usr&#x2F;local&#x2F;share&#x2F;ca-certificates”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> selfsigned-certificate.crt /usr/local/share/ca-certificates<br></code></pre></td></tr></table></figure></li><li><p>更新CA存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-ca-certificates<br></code></pre></td></tr></table></figure></li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol><li><p>从目录“&#x2F;usr&#x2F;local&#x2F;share&#x2F;ca-certificates”中删除证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> /usr/local/share/ca-certificates/selfsigned-certificate.crt<br></code></pre></td></tr></table></figure></li><li><p>更新CA存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-ca-certificates --fresh<br></code></pre></td></tr></table></figure></li></ol><h3 id="CentOS-RedHat"><a href="#CentOS-RedHat" class="headerlink" title="CentOS, RedHat"></a>CentOS, RedHat</h3><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><ol><li><p>将证书拷贝到目录“&#x2F;etc&#x2F;pki&#x2F;ca-trust&#x2F;source&#x2F;anchors”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> selfsigned-certificate.crt /etc/pki/ca-trust/source/anchors<br></code></pre></td></tr></table></figure></li><li><p>更新CA存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-ca-trust<br></code></pre></td></tr></table></figure></li></ol><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ol><li><p>从目录“&#x2F;etc&#x2F;pki&#x2F;ca-trust&#x2F;source&#x2F;anchors”中删除证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> /etc/pki/ca-trust/source/anchors/selfsigned-certificate.crt<br></code></pre></td></tr></table></figure></li><li><p>更新CA存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-ca-trust<br></code></pre></td></tr></table></figure></li></ol><h2 id="Mac客户端"><a href="#Mac客户端" class="headerlink" title="Mac客户端"></a>Mac客户端</h2><h4 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain selfsigned-certificate.crt<br></code></pre></td></tr></table></figure><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo security delete-certificate -c <span class="hljs-string">&quot;&lt;Common Name of existing certificate&gt;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的&lt; Common Name of existing certificate&gt;是指创建证书时提示输入的Common Name (e.g. server FQDN or YOUR name) []: &lt; Domain name or Server IP address&gt;</p></blockquote><p>或者通过证书的SHA-1码来删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo security delete-certificate -Z &lt;SHA-1 Hash&gt;<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过命令”security find-ceritificate -a -Z -c &lt; Common Name of existing certificate&gt;”可以获得证书的SHA-1码。</p></blockquote><h2 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h2><h4 id="添加-3"><a href="#添加-3" class="headerlink" title="添加"></a>添加</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs batch">certutil -addstore -f &quot;Root&quot; selfsigned-certificate.crt<br></code></pre></td></tr></table></figure><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs batch">certutil -delstore &quot;Root&quot; &lt;Cert Serial Number&gt;<br></code></pre></td></tr></table></figure><blockquote><p>通过命令”certutil -store “Root””可以获得证书的Serial Number。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>System Management</tag>
      
      <tag>TLS/SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terraform如何调用Ansible配置虚拟机资源</title>
    <link href="/2018/11/14/terraform-call-ansible/"/>
    <url>/2018/11/14/terraform-call-ansible/</url>
    
    <content type="html"><![CDATA[<p>Terraform（<a href="https://www.terraform.io/">https://www.terraform.io/</a>）是一款开源的基础架构即代码(Infrastructure As Code - IAC)工具，通过代码来构建和变更基础架构，并且能够管理变更的版本。Terraform在构建出虚拟机资源后，往往会调用与其关联的provisoner来配置虚拟机资源，比如变更某个系统配置，设置环境变量或者部署某个应用，但是Terraform目前并没有提供开箱即用的支持Ansible的provisioner（也许随着版本的升级，会提供）。本文基于vSphere数据中心和Ubuntu系统实现一种Terraform调用Ansible配置虚拟机资源的方法。</p><span id="more"></span><h1 id="Terraform架构简介"><a href="#Terraform架构简介" class="headerlink" title="Terraform架构简介"></a>Terraform架构简介</h1><p>为了方便后续步骤的理解，在这里对Terraform及其相关组件做一简单介绍。这是Terraform的架构图：<br><img src="/2018/11/14/terraform-call-ansible/1.jpg"></p><p>Terraform调用不同云平台（公有或私有）的“Provider”创建和编排基础架构资源，调用不同的“Provisioner”配置新生成的资源。并不是所有的资源都支持“Provisioner”，可以参考对应资源的帮助文档来了解是否支持。基本上，虚拟机资源，比如ECS, EC2等，都支持调用“Provisioner”去配置。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>组合利用Terraform现有的Provisioner为新创建的虚拟机生成动态的Ansible资源文件，加入到Ansible当前资源文件夹中（Ansible在执行时会合并当前资源文件加下的所有资源文件），最后基于动态资源执行Ansible脚本配置新创建的虚拟机。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>以自动创建一台虚拟机资源并安装和配置Artifactory软件为例，下图是Terraform+Ansible的代码结构：<br>.<br>├── ansible<br>│   ├── handlers<br>│   ├── inventory<br>│   │   ├── devops<br>│   │   │   ├── group_vars<br>│   │   │   ├── host_vars<br>│   │   │   └── hosts<br>│   │   └── devops-disconf<br>│   │       └── hosts<br>│   ├── roles<br>│   ├── templates<br>│   │   ├── artifactory<br>│   │   │   └── hosts.temp.j2<br>│   ├── configure-ansible-node.sh<br>│   ├── ansible.cfg<br>│   ├── terraform-ansible-inventory.yaml<br>│   ├── artifactory.yaml<br>├── iac<br>│   └── cicd<br>│       ├── vsphere_virtual_machine_art1.tf</p><blockquote><p>Artifactory是一款统一制品管理工具，支持多种标准的软件包格式：Maven（Gradle），Nuget，NPM，Bower，CocoaPods，Docker，Debian，RPM…，也支持自定义存储格式。Artifactory是构建CI&#x2F;CD流程必不可少的一个工具。</p></blockquote><h2 id="ansible目录"><a href="#ansible目录" class="headerlink" title="ansible目录"></a>ansible目录</h2><p>这个目录是典型的Ansible工程目录，有handlers，inventory，roles，templates，ansible.cfg，*.yaml（Ansible playbook）。</p><ul><li><p>ansible.cfg</p><p>设置缺省的资源文件夹，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">defaults</span>]<br><span class="hljs-string">inventory</span> <span class="hljs-string">=</span> <span class="hljs-string">./inventory/devops</span><br></code></pre></td></tr></table></figure><p>在资源文件夹中，一般会有一个缺省的资源文件hosts，另外还有组变量文件和主机变量文件。</p></li><li><p>configure-ansible-node.sh</p><p>Shell脚本，用来在新创建的虚拟机中（Ubuntu）安装Python，以便将这台虚拟机配置成Ansible的管理节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash -il</span><br><br>py_version=2.7.12-1~16.04<br><br><span class="hljs-keyword">if</span> [ -f /var/lib/apt/lists/lock ]<br><span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">rm</span> -f /var/lib/apt/lists/lock<br><span class="hljs-keyword">fi</span><br><br>result=$(dpkg-query -W  python | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;result&#125;</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Installing python=<span class="hljs-variable">$&#123;py_version&#125;</span>&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;python was already installed!&quot;</span><br>  <span class="hljs-built_in">exit</span> 0<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">export</span> http_proxy=http://xxxx<br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-variable">$&#123;http_proxy&#125;</span><br><br><span class="hljs-built_in">cat</span> &gt; /etc/apt/apt.conf.d/apt-temp.conf &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">Acquire::http::Proxy &quot;$&#123;http_proxy&#125;&quot;;</span><br><span class="hljs-string">Acquire::https::Proxy &quot;$&#123;http_proxy&#125;&quot;;</span><br><span class="hljs-string">Acquire::ftp::Proxy &quot;$&#123;http_proxy&#125;&quot;;</span><br><span class="hljs-string">EOF</span><br><br>apt-get update<br>apt-get -y --no-upgrade install python=<span class="hljs-variable">$&#123;py_version&#125;</span><br><br>curl https://bootstrap.pypa.io/get-pip.py | python<br>pip install -U pip<br><br><span class="hljs-built_in">rm</span> -f /etc/apt/apt.conf.d/apt-temp.conf<br></code></pre></td></tr></table></figure><p>如果代码是运行在防火墙后面，比如在公司的网络中，需要line 19 - line 26的代码配置apt代理。</p></li><li><p>terraform-ansible-inventory.yaml</p><p>Ansible脚本，用来生成当前虚拟机的动态资源文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span>  <span class="hljs-string">Create</span> <span class="hljs-string">temp</span> <span class="hljs-string">inventory</span> <span class="hljs-string">file</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; host | default(&#x27;localhost&#x27;) &#125;&#125;</span>&quot;</span><br>  <span class="hljs-attr">vars:</span><br>    <span class="hljs-attr">host_name:</span> <span class="hljs-string">default-temp</span><br>    <span class="hljs-attr">host_ip:</span> <span class="hljs-string">xxx.xxx.xxx.xxx</span><br>    <span class="hljs-attr">host_user:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">host_password:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">temp</span> <span class="hljs-string">inventory</span> <span class="hljs-string">file</span><br>      <span class="hljs-attr">template:</span> <span class="hljs-string">src=artifactory/hosts.temp.j2</span> <span class="hljs-string">dest=inventory/devops/&#123;&#123;host_name&#125;&#125;</span> <span class="hljs-string">mode=644</span><br>      <span class="hljs-attr">delegate_to:</span> <span class="hljs-string">localhost</span><br></code></pre></td></tr></table></figure><p>本地执行这个Ansible脚本从以下模板（hosts.temp.j2）实例化出Ansible的资源文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123;<span class="hljs-string">host_name</span>&#125;&#125; <span class="hljs-string">ansible_host=&#123;&#123;host_ip&#125;&#125;</span> <span class="hljs-string">ansible_user=&#123;&#123;host_user&#125;&#125;</span> <span class="hljs-string">ansible_password=&#123;&#123;host_password&#125;&#125;</span> <span class="hljs-string">ansible_ssh_common_args=&#x27;-o</span> <span class="hljs-string">StrictHostKeyChecking=no&#x27;</span><br><br>[<span class="hljs-string">packer_node</span>]<br>&#123;&#123;<span class="hljs-string">host_name</span>&#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为在动态资源文件中使用了用户名和密码的方式访问虚拟机。需要在Ansible控制机上安装sshpass。</p></blockquote></li></ul><h2 id="iac目录"><a href="#iac目录" class="headerlink" title="iac目录"></a>iac目录</h2><p>这个目录用来存放Terraform配置文件。</p><ul><li><p>vsphere_virtual_machine_art1.tf</p><p>Terraform配置文件，在vsphere中从某个虚拟机模板克隆创建一台新的虚拟机资源。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">provider</span> <span class="hljs-string">&quot;vsphere&quot;</span> &#123;<br>  <span class="hljs-string">vsphere_server</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;xxx.xxx.xxx.xxx&quot;</span><br>  <span class="hljs-string">user</span>           <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>  <span class="hljs-string">password</span>       <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>  <span class="hljs-string">allow_unverified_ssl</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-string">resource</span> <span class="hljs-string">&quot;vsphere_virtual_machine&quot;</span> <span class="hljs-string">&quot;art1&quot;</span> &#123;<br>  <span class="hljs-string">...</span><br><br>  <span class="hljs-string">clone</span> &#123;<br>    <span class="hljs-string">template_uuid</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>    <span class="hljs-string">...</span><br>  &#125;<br><br>  <span class="hljs-string">provisioner</span> <span class="hljs-string">&quot;file&quot;</span> &#123;<br>    <span class="hljs-string">source</span>      <span class="hljs-string">=</span> <span class="hljs-string">&quot;../../ansible/configure-ansible-node.sh&quot;</span><br>    <span class="hljs-string">destination</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;/tmp/configure-ansible-node.sh&quot;</span><br><br>    <span class="hljs-string">connection</span> &#123;<br>      <span class="hljs-string">type</span>        <span class="hljs-string">=</span> <span class="hljs-string">&quot;ssh&quot;</span><br>      <span class="hljs-string">user</span>        <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>      <span class="hljs-string">password</span>    <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>      <span class="hljs-string">agent</span>       <span class="hljs-string">=</span> <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-string">provisioner</span> <span class="hljs-string">&quot;remote-exec&quot;</span> &#123;<br>    <span class="hljs-string">inline</span> <span class="hljs-string">=</span> [<span class="hljs-string">&quot;chmod a+x /tmp/configure-ansible-node.sh&quot;</span>,<br>              <span class="hljs-string">&quot;/tmp/configure-ansible-node.sh&quot;</span>,<br>              <span class="hljs-string">&quot;rm -f /tmp/configure-ansible-node.sh&quot;</span>]<br><br>    <span class="hljs-string">connection</span> &#123;<br>      <span class="hljs-string">type</span>        <span class="hljs-string">=</span> <span class="hljs-string">&quot;ssh&quot;</span><br>      <span class="hljs-string">user</span>        <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>      <span class="hljs-string">password</span>    <span class="hljs-string">=</span> <span class="hljs-string">&quot;...&quot;</span><br>      <span class="hljs-string">agent</span>       <span class="hljs-string">=</span> <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-string">provisioner</span> <span class="hljs-string">&quot;local-exec&quot;</span> &#123;<br>    <span class="hljs-string">command</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;ansible-playbook -e host_name=default_art1 -e host_ip=$&#123;vsphere_virtual_machine.art1.default_ip_address&#125; terraform-ansible-inventory.yaml&quot;</span>,<br>    <span class="hljs-string">working_dir</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;../../ansible&quot;</span><br>  &#125;<br><br>  <span class="hljs-string">provisioner</span> <span class="hljs-string">&quot;local-exec&quot;</span> &#123;<br>    <span class="hljs-string">command</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;ansible-playbook  -e host=default_art1 artifactory.yaml&quot;</span>,<br>    <span class="hljs-string">working_dir</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;../../ansible&quot;</span><br>  &#125;<br><br>  <span class="hljs-string">provisioner</span> <span class="hljs-string">&quot;local-exec&quot;</span> &#123;<br>      <span class="hljs-string">command</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;rm -f inventory/devops/default_art1&quot;</span>,<br>      <span class="hljs-string">working_dir</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;../../ansible&quot;</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>line16 - line26：利用Terraform的”file“provisioner上传安装Python的Shell脚本</p></li><li><p>line28 - line39：利用Terraform的”remote-exec“provisioner执行安装Python的Shell脚本</p></li><li><p>line41 - line44：获取新生成的虚拟机IP地址，利用Terraform的”local-exec“provisioner本地执行“terraform-ansible-inventory.yaml”生成Ansible的动态资源文件</p></li><li><p>line46 - line49：利用Terraform的”local-exec“provisioner基于Ansible的动态资源文件执行Ansible脚本完成应用的部署和配置</p></li><li><p>line51 - line54：利用Terraform的”local-exec“provisioner执行Shell命令删除动态资源文件</p></li></ul></li></ul><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这个方法同样也适用于在公有云平台上创建虚拟机实例并调用Ansible脚本完成配置，但需要为虚拟机实例绑定一个动态的公网IP地址。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>Infrastructure As Code</tag>
      
      <tag>Terraform</tag>
      
      <tag>Ansible</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Jenkins Freestyle Job构建CI/CD流水线</title>
    <link href="/2018/10/07/jenkins-freestyle-cicd-pipeline/"/>
    <url>/2018/10/07/jenkins-freestyle-cicd-pipeline/</url>
    
    <content type="html"><![CDATA[<p>可能有人会问：“现在流行的是Jenkins Pipeline 2.0(Jenkinsfile)，所有人都在谈论和使用, 为什么还在用Freestyle Job, 是不是太low了！”。的确，Jenkins Pipeline 2.0现在很流行，几乎就等同于Jenkins平台上构建CI&#x2F;CD流水线的标准，如果你不使用Jenkins Pipeline 2.0，那么就等于不懂CI&#x2F;CD。我承认Jenkins Pipeline 2.0带来了很多革命性的理念，比如Build As Code, 但是我想说的是Jenkins Pipeline 2.0不等于CI&#x2F;CD Pipeline,而且它的革命也不是很彻底。不过本文不会过多地去议论方法或工具的好坏，只是在Jenkins上利用一种非Jenkins Pipeline 2.0的方式去构建CI&#x2F;CD流水线，并说明这种流水线的优缺点，以期能够给读者一次思维上的刷新。</p><span id="more"></span><h1 id="一个典型的CI-x2F-CD流水线"><a href="#一个典型的CI-x2F-CD流水线" class="headerlink" title="一个典型的CI&#x2F;CD流水线"></a>一个典型的CI&#x2F;CD流水线</h1><p><img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/2.png"></p><p>上图是个典型的CI&#x2F;CD流水线，由5个阶段（Phase）组成：Build&#x2F;UT，Code Static Check，QA，STAGE和PROD。每个阶段（Phase）由一到多个任务（Task）组成，每个阶段（Phase）都有一个主任务（Task），阶段（Phase）之间的提升（Promotion）是由主任务（Task）的提升（Promotion）完成。同一个阶段（Phase）之间的任务（Task）可以串行执行，也可以并行执行。</p><p>如果一个任务（Task）是通过提升（Promotion）的方式触发的，那么在当前流水线中这个任务（Task）可以被重复触发。这为流水线带来了两个好处：</p><ul><li><p>流水线可以从失败的点重新启动，而无需重新启动一个新的流水线实例：<br>当一个任务（Task）的执行由于某种临时原因失败了，比如网络不稳定，磁盘空间满了，断电等，可以通过重新提升（Promotion）再次触发。尤其是在前置阶段（Phase）和任务（Task）比较耗时，或者需要征用外部资源的时候，这一点更显得重要。</p></li><li><p>调试CI&#x2F;CD流水线时，无需重复启动一个新的流水线实例：<br>这一点其实是上优点的延伸。调试流水线时往往是从前往后一个阶段（Phase）一个阶段（Phase）的调试，正是由于流水线可以从失败的点重新启动，可以直接略过通过的阶段（Phase），从失败的阶段（Phase）开始调试。</p></li></ul><p>手动提升（Manual Promote）策略需要有权限的批准者根据提前制定好的质量关卡来决定是否需要提升（Promote）到下一个阶段（Phase）。在这个流水线中，QA阶段（Phase）到STAGE阶段（Phase），STAGE阶段（Phase）到PROD阶段（Phase）都需要手动提升（Mannual Promote），它们并不是在每一个流水线实例中都需要被触发。在开发的早期，软件还不是很稳定的时候，每一次的代码提交都会触发一个流水线实例，流水线实例往往会根据自动提升（Auto Promote）策略最大限度地往后续阶段（Phase）流转，如果在某一阶段（Phase）失败了，则会及时通知到相关开发人员，从而实现了及时反馈当前代码提交对软件质量的影响。</p><p>只要没有被清理掉， 流水线实例可以在任何时间被重新启动，状态也会自动恢复。这为流水线带来了以下的好处：</p><ul><li><p>有时候由于质量和时间的原因，不一定会将最新版本的流水线实例从STAGE阶段（Phase）提升到PROD阶段（Phase），而是需要将几天前的已经处于STAGE阶段（Phase）的流水线实例提升到PROD阶段（Phase）；</p></li><li><p>流水线在停止状态不会占用任何Jenkins Master 或者 Slave节点资源。</p></li></ul><blockquote><p>往往是在第一个阶段（Phase）的构建（Build）任务（Task）中生成状态文件，后续阶段（Phase）只是拷贝和恢复，也有可能会添加更多的状态。</p></blockquote><p>下图是状态存储与恢复的过程。</p><p><img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/3.png"></p><p>在上游阶段（Phase）的任务（Task）也就是Jenkins作业（Job）中将需要持久的状态以key-value的方式存储到build-info.prop文件中，并通过Jenkins Job的存档功能（Archive）将build-info.prop存到当前作业（Job）上，下游被触发的Jenkin作业（job）将上游作业（Job）的build-info.prop拷贝到本地工作区，将它注入为环境变量。</p><h1 id="在Jenkins上实现这个CI-x2F-CD流水线"><a href="#在Jenkins上实现这个CI-x2F-CD流水线" class="headerlink" title="在Jenkins上实现这个CI&#x2F;CD流水线"></a>在Jenkins上实现这个CI&#x2F;CD流水线</h1><h2 id="Jenkins和必要的插件"><a href="#Jenkins和必要的插件" class="headerlink" title="Jenkins和必要的插件"></a>Jenkins和必要的插件</h2><ol><li><p>Jenkins<br>从Jenkins官网（<a href="https://jenkins.io/">https://jenkins.io</a>）上下载最新版本的Jenkins并安装。或者，至少保证你的Jenkins版本在2.0以上，1.x版本还是太旧了。</p></li><li><p>必要的插件</p><ul><li><p>Parameterized Trigger Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Parameterized+Trigger+Plugin">https://wiki.jenkins.io/display/JENKINS/Parameterized+Trigger+Plugin</a></p><p>在Jenkins pipeline2.0之前，Job之前的调用与被调用关系是通过这个插件或者一系列同类的插件实现的。</p></li><li><p>Delivery Pipeline Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Delivery+Pipeline+Plugin">https://wiki.jenkins.io/display/JENKINS/Delivery+Pipeline+Plugin</a></p><p>将Job的上下游调用关系图形化显示为流水线。这个插件实现了CI&#x2F;CD流水线的两个概念：阶段（Phase）和任务（Task）。一个任务（Task）就是一个Jenkins Freestyle Job（作业），一个阶段（Phase）可以包含多个任务（Task）。下图是从插件的网站上截取出来的最终CI&#x2F;CD流水线的样式：<br><img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/1.png"></p></li><li><p>Promte Builds Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Promoted+Builds+Plugin">https://wiki.jenkins.io/display/JENKINS/Promoted+Builds+Plugin</a></p><p>这个插件提供了一系列上下游作业（Job）之间的触发策略，主要分为自动触发，手动批准触发和自定义条件触发。除了三种主要的触发策略，还提供了一些更精细的控制策略，比如当前的提升（promotion）依赖于另一个提升（promotion）。可参考插件的wiki文档和内联的注释详细了解每一个触发策略，选中适合当前CI&#x2F;CD流水线建设的要求。</p></li><li><p>Copy Artifact Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Copy+Artifact+Plugin">https://wiki.jenkins.io/display/JENKINS/Copy+Artifact+Plugin</a></p><p>这个插件实现了实现了上下游作业（Job）传递数据的功能。在构建CI&#x2F;CD流水线时，会将流水线的状态数据以key-value值的方式记录在文本文件中，并存档在当前的作业（Job）中。下游的作业（Job）可以通过这个插件从触发它的上游作业（Job）拷贝这个状态数据文件，加载成环境变量，从而实现状态的恢复。</p></li><li><p>EnvInject Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/EnvInject+Plugin">https://wiki.jenkins.io/display/JENKINS/EnvInject+Plugin</a></p><p>利用这个插件可以将流水线的以key-value值的方式存储的状态文件加载为当前阶段（Phase）当前任务（Task）的环境变量。</p><blockquote><p>注意，key的名字不要包含中划线，否则Jenkins 作业（Job）不识别。<br>以上五个插件是实现CI&#x2F;CD流水线必需的插件，装这四个插件可能还会自动安装一些依赖的插件。</p></blockquote></li><li><p>Description Setter Plugin<br><a href="http://wiki.jenkins-ci.org/display/JENKINS/Description+Setter+Plugin">http://wiki.jenkins-ci.org/display/JENKINS/Description+Setter+Plugin</a></p><p>这个插件比较简单了，主要是用来设置Job(Task)的描述，这样在CI&#x2F;CD流水线中能显示更多的信息。</p></li><li><p>Flexible Publish Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Flexible+Publish+Plugin">https://wiki.jenkins.io/display/JENKINS/Flexible+Publish+Plugin</a></p><p>这个插件主要是用来实现作业（Job）中的步骤（step）的控制流，扩展了Jenkins 作业（Job）的步骤（steps）只能顺序执行的方式。</p></li><li><p>Email-ext Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin">https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin</a></p><p>扩展的邮件插件，能够定制复杂的邮件内容。邮件通知是一个成熟的CI&#x2F;CD流水线必要的特征。</p></li><li><p>Token Macro Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Token+Macro+Plugin">https://wiki.jenkins.io/display/JENKINS/Token+Macro+Plugin</a></p><p>在作业（Job）的描述或通知邮件的内容中可以通过引用Jenkins当前构建（build）的环境变量实现描述或邮件内容的模板化。Token Macro插件则负责在运行时解析这些变量引用。</p></li></ul></li></ol><h2 id="Jenkins-Job配置"><a href="#Jenkins-Job配置" class="headerlink" title="Jenkins Job配置"></a>Jenkins Job配置</h2><p>为了实现这个CI&#x2F;CD流水线，下图是一个Jenkins Job所需的步骤，但并不是所有的Job都需要实现所有的步骤。比如Build&#x2F;UT阶段（Phase）的Build任务（Task）是整个流水线的第一个Jenkins作业（Job），所以不需要步骤3去拷贝流水线状态文件，也不需要步骤4去加载状态文件，而最后一个Smoke Test任务（Task）也不要步骤2去提升（Promote）到下一个阶段（Phase）或者任务（Task）。</p><p><img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/4.png"></p><p>步骤的一些说明：</p><ol><li><p>配置“Delivery Pipeline”节。“Stage Name”是阶段（Phase）名，“Task Name”是这个Jenkins Job在这个阶段（Phase）中的任务（Task）名字；</p></li><li><p>Jenkins作业（Job）提升（Promotion）的配置。在“Criteria”下选择提升（Promotion）的策略，在“Actions”中选择待触发的下游Jenkins作业（Job）；</p></li><li><p>从上游作业（Job）拷贝流水线状态文件；</p></li><li><p>将状态文件加载为当前作业（Job）的环境变量。</p></li></ol><h2 id="如何提升（Promote）阶段（Phase）或任务（Task）"><a href="#如何提升（Promote）阶段（Phase）或任务（Task）" class="headerlink" title="如何提升（Promote）阶段（Phase）或任务（Task）"></a>如何提升（Promote）阶段（Phase）或任务（Task）</h2><p>下图展示了如何提升（Promote）阶段（Phase）或任务（Task），也就是Jenkins作业（Job）：<br><img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/5.png"></p><p>步骤的一些说明：</p><ol><li><p>在当前的流水线实例中打开上游作业（Job）的构建（Build）页面，点击左侧链接“Promotions Status”；</p></li><li><p>只有在“Approvers”列表里的用户有权手动批准提升（Promotion）；</p></li><li><p>点击“Approve”按钮触发提升（Promotion）；</p></li><li><p>Jenkins管理员有权限强制提升（Promotion）；</p></li><li><p>通过点击“Re-execute promotion”可重复提升（Promote）当前的作业（Job）。</p></li></ol><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>每一种方法有它的优点，必定也有它的缺点，没有一种方法是银弹，可以解决一切问题，打败天下无敌手。是否使用它，就要自己去权衡：是它的优点给你带来了更多，还是它的缺点是当前的最大障碍。这种方法的缺点大致如下：</p><ol><li><p>仅管“Delivery Pipeline Plugin”可以图形化显示Jenkins Pipeline 2.0（Jenkinsfile）作业（Job）的上下游调用关系，但是“Promotes Builds Plugin”不支持Jenkins Pipeline 2.0（Jenkinsfile），所以太多的Freestyle Job要去创建，设置和维护，这些Job只能作为配置存储在Jenkins Master服务器上，而不能作为代码存储在Git中；</p></li><li><p>会多占用一些Slave节点的线程，因为作业（Job）的提升其实也是作业（Job）需要占用一个Slave线程。</p></li></ol><p>期待“Promotes Builds Plugin”能够支持Jenkins Pipeline 2.0 （Jenkinfile），这样所有的任务（Task）也就是Jenkins作业（Job）全部可以作为代码存储在Git中，而且维护起来也很方便。</p>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Gitee(码云)搭建静态博客网站</title>
    <link href="/2018/08/17/setup-blog-hexo-gitee/"/>
    <url>/2018/08/17/setup-blog-hexo-gitee/</url>
    
    <content type="html"><![CDATA[<p>直接注册和使用当下比较流行的博客网站比如csdn, oschina, 博客园等等，觉得不是自己专属，而且还有很多广告。选择一款开源或免费的CMS(内容管理系统)，自己买云主机和域名搭建博客，费钱又费时。有时我们只是希望有一个功能不太复杂，自己专属的或者看起来自己专属的（至少没有一堆广告）博客网站来写写和分享自己的文章。不需要花费太多的时间和钱，除非你的博客和文章已经足够热门。基于以上的期望，本文将介绍如何使用Hexo搭建静态博客网站，并将其发布到GITEE(码云)免费提供的静态网页空间里。</p><span id="more"></span><h1 id="Hexo是什么"><a href="#Hexo是什么" class="headerlink" title="Hexo是什么"></a>Hexo是什么</h1><p>Hexo是一款免费的用来快速搭建静态博客网站的框架。支持插件机制，简单又不失强大。Hexo是基于Node.js开发的，提供了一组命令用来创建和管理博客应用，创建和管理博客文章，将博客应用和文章发布成静态博客网站。Hexo使用Markdown语言来写博客，方便、快捷，不需要什么额外的排版工具就能使你的文章布局看起来很美观。下图是Hexo博客网站的结构：<br><img src="/2018/08/17/setup-blog-hexo-gitee/1.png"></p><h1 id="Gitee是什么"><a href="#Gitee是什么" class="headerlink" title="Gitee是什么"></a>Gitee是什么</h1><p>Gitee（码云 <a href="https://gitee.com/">gitee.com</a>）是国内的一款基于Git的代码托管和协作开发平台，和GitHub, GitLab属于同一类型的产品。同GitHub和GitLab相比，Gitee具有以下几点优势：</p><ul><li>支持免费的私有Git代码仓库</li><li>在国内，不需要科学上网，访问速度快</li></ul><p>Gitee平台也提供了免费的静态页面托管服务“码云Pages”，可以用来托管博客，项目官网等静态网页。“码云Pages Pro”是这个服务的高阶收费版，支持发布代码仓库中的某个目录，支持自定义域名。</p><blockquote><p>要详细了解Gitee的概念和使用，可以参考Gitee的官方在线帮助文档：<a href="https://gitee.com/help">https://gitee.com/help</a></p></blockquote><p>本文将会在Gitee上创建Git代码仓库管理Hexo博客应用的代码和静态博客网站，同时将静态博客网页托管到“码云Pages”。</p><h1 id="从零开始搭建专属博客"><a href="#从零开始搭建专属博客" class="headerlink" title="从零开始搭建专属博客"></a>从零开始搭建专属博客</h1><p>介绍完Hexo和Gitee后，明白了它们的概念和用途。下面我们就从零开始完整地搭建一个自己专属的博客。</p><h2 id="安装必备的软件"><a href="#安装必备的软件" class="headerlink" title="安装必备的软件"></a>安装必备的软件</h2><ul><li>安装Node.js<ul><li>Mac上安装</li><li>Linux上安装</li><li>Windows上安装</li></ul></li><li>安装Git客户端<ul><li>Mac上安装</li><li>Linux上安装</li><li>Windows上安装</li></ul></li></ul><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>运行以下命令安装Hexo（Hexo命令行）到Node.js的全局空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><blockquote><p>Hexo是用Node.js开发的，所以它以npm包格式发布。</p></blockquote><h2 id="创建一个新的博客应用"><a href="#创建一个新的博客应用" class="headerlink" title="创建一个新的博客应用"></a>创建一个新的博客应用</h2><ol><li><p>依次执行以下shell命令创建一个缺省的博客应用：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init hexo-test-blog<br><span class="hljs-built_in">cd</span> hexo-test-blog<br>npm install<br></code></pre></td></tr></table></figure><blockquote><p>博客应用的文件结构：<br>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>│   ├── draft.md<br>│   ├── page.md<br>│   └── post.md<br>├── source<br>│   └── _posts<br>│   └── _drafts<br>└── themes<br>│   └── landscape  </p><ul><li>_config.yml<br>博客站点配置文件。</li><li>package.json<br>博客应用引用的第三方Node.js包。</li><li>scaffolds<br>脚手架是用来快速创建博客页面的模板。有三类模板，“文章”，“草稿”和“页面”。脚手架不是最终博客页面显示的模板，显示是由当前主题的layout文件夹中的模板负责。</li><li>source<br>博客文章的存放目录。分为“_posts”和“_drafts”两个子目录，分别存放正式文章和草稿文章。</li><li>themes<br>Hexo博客的主题。缺省安装的主题是“landscape”。</li></ul></blockquote></li><li><p>执行以下命令构建博客应用，生成静态博客网站</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm intall<br>hexo generate<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令启动一个本地http服务查看静态博客网站  </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><blockquote><p>在浏览器中输入http<nolink>:&#x2F;&#x2F;localhost:4000打开博客网站。</p></blockquote></li><li><p>设置一些“应用配置”(_config.yml)</p><blockquote><p>这里将根目录下的配置文件”_config.yml“称为”应用配置“以便与后面的“主题配置”区分看来。”主题配置“是位于博客应用的主题根目录下的配置文件，名字也是”_config.yml“。</p></blockquote><ul><li><p>title: 若一拾得</p></li><li><p>subtitle: 若一不一，知之不知</p></li><li><p>description:</p></li><li><p>keywords: DevOps, Infrastructure As Code(IAC), CI&#x2F;CD, Operation, Monitor, Python</p></li><li><p>author: 若一</p></li><li><p>language: zh-Hans</p></li><li><p>timezone: Asia&#x2F;Shanghai</p></li><li><p>url: <a href="http://www.ruokiy.com/">http://www.ruokiy.com</a></p></li><li><p>root: &#x2F;</p></li><li><p>permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; &#x3D;&gt; 文章页面的永久链接</p></li><li><p>permalink_defaults:</p><blockquote><p>可以参考Hexo的官方文档了解更多的Hexo命令。</p></blockquote></li></ul></li></ol><h2 id="为博客应用安装新的主题"><a href="#为博客应用安装新的主题" class="headerlink" title="为博客应用安装新的主题"></a>为博客应用安装新的主题</h2><p>Hexo自带的主题“landscape”看起来平平，不够简洁也不够富丽，所以大部分人安装和初始化完Hexo博客应用后，接下来的一步就是安装配置自己喜欢的主题。下面就以以简洁著称的“NexT”主题为例，介绍安装和配置主题的步骤。</p><p>“NexT”主题在GitHub上，地址为<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a>。</p><blockquote><p>注意：GitHub上还有很多“NexT”的fork版, 上面的地址是官方最新的版本。<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a>是“NexT”的一个老版本。</p></blockquote><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li><p>克隆“NexT”主题到博客应用的themes目录</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure></li><li><p>修改“应用配置”使用“NexT”主题</p><ul><li>theme: next</li></ul></li></ol><h3 id="对“NexT”主题的一些配置"><a href="#对“NexT”主题的一些配置" class="headerlink" title="对“NexT”主题的一些配置"></a>对“NexT”主题的一些配置</h3><p>这个段落加上后面的对接第三发系统部分将介绍一些常用的配置。如果需要更多的设置，可详细浏览“应用配置”和“主题配置”中的每一个可更改的配置，并参考对应的文档，或者Google、Baidu来了解配置的作用，分析是否能满足你的要求。</p><ul><li><p>去除页脚中的有关“NexT”的信息和链接</p><p>编辑“主题配置”，将“footer|powered|enable”，“footer|powerer|version”，“footer|theme|enable”以及“footer|theme|version”都设成“false”。</p></li><li><p>添加“about”和“tags”页<br>Hexo缺省支持这两个类型的页面。<br>(1) 执行下面的命令，在根目录下的source目录中分别创建“about”和“tags”文件夹</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br>hexo new page tags<br></code></pre></td></tr></table></figure><p>(2) 编辑“根目录&#x2F;source&#x2F;tags&#x2F;index.md”，在头部加上“type: tags”</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2018-08-17 14:57:19</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">comments:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>(3) 编辑“主题配置”，将“menu|about”和“menu|tags”打开</p></li><li><p>设置博客版面样式<br>也就是博客网站的样式，比如一列或者两列。可以通过“主题配置”中的“scheme”来设置。</p></li><li><p>开启博客首页文章自动摘录，以及摘录字数限制<br>编辑“主题配置”，将“auto_excerpt|enable”设成“true”，设置“auto_excerpt|length”为指定的摘录字数。</p><blockquote><p>根据描述，你也可以用符号“&lt;!-- more --&gt;”来精确控制自动摘录的结束点。</p></blockquote></li></ul><h2 id="对接第三发系统完善博客应用"><a href="#对接第三发系统完善博客应用" class="headerlink" title="对接第三发系统完善博客应用"></a>对接第三发系统完善博客应用</h2><p>由于Hexo产生的是静态博客网站，没有自己的独立数据库，所以很多功能需要利用第三方服务或者插件来完成。</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>如果不能科学上网的话，基本上不太可能使用国外的评论系统比如Disqus，Hypercomments，LiveRe等，要么访问速度慢，要么被墙。而国内可用的第三方评论系统也不是很多，多说和网易云跟帖已经关闭，畅言需要提供你的网站ICP备案号，否则只有15天的试用期。经过比较，发现Valine是一个比较轻量级的评论系统，速度快，不需要网站备案（说不定以后需要，先用着再说！）。</p><blockquote><p>如果非要尝试畅言的话，可以参考这个博客文章<a href="https://blog.csdn.net/qq_32518231/article/details/78080184">https://blog.csdn.net/qq_32518231&#x2F;article&#x2F;details&#x2F;78080184</a></p></blockquote><p>给你的博客应用设置Valine评论系统的步骤：<br>(1) 在LeanCloud<a href="https://www.leancloud.cn/">https://www.leancloud.cn</a>上注册一个账号；</p><pre><code class="hljs">博客的评论将存储在LeadCloud中。</code></pre><p>(2) 进入控制台，创建一个开发版的应用；</p><p>(3) 点击进入这个应用，并进入设置|应用key页面获取APP ID和APP KEY；</p><p>(4) 修改主题配置，将valine|enable设为true，valine|appid设为上一步获取的APP ID，valine|appkey设为上一步获取的APP KEY。</p><pre><code class="hljs">需要将你的静态博客发布到线上才会看到文章末尾的valine评论模块</code></pre><h3 id="文章统计"><a href="#文章统计" class="headerlink" title="文章统计"></a>文章统计</h3><ul><li><p>添加“文章字数”和“文章平均阅读时间”统计。</p><p>  (1) 在博客应用的根目录执行以下命令安装“hexo-sysmbols-count-time”插件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-symbols-count-time --save<br></code></pre></td></tr></table></figure><p>  (2) 修改<strong>应用配置</strong>添加以下配置加载“hexo-symbols-count-time”插件</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">symbols_count_time:</span><br><span class="hljs-attr">symbols:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">time:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">total_symbols:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">total_time:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>  (3) 修改<strong>主题配置</strong>中的以下配置</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">symbols_count_time:</span><br><span class="hljs-attr">separated_meta:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">item_text_post:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">item_text_total:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">awl:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">wpm:</span> <span class="hljs-number">275</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="社交分享"><a href="#社交分享" class="headerlink" title="社交分享"></a>社交分享</h3><p>添加模块<a href="https://github.com/theme-next/theme-next-needmoreshare2">https://github.com/theme-next/theme-next-needmoreshare2</a>获得博客文章社交分享的功能。</p><p>(1) 执行以下命令安装needmoreshare模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> themes/next<br>git <span class="hljs-built_in">clone</span> https://github.com/theme-next/theme-next-needmoreshare2 <span class="hljs-built_in">source</span>/lib/needsharebutton<br></code></pre></td></tr></table></figure><pre><code class="hljs">注意，这里一定得是克隆到“source/lib/needsharebutton”目录，名字不能错。</code></pre><p>(2) 修改“主题配置”“needmoreshare2”的子选项开启社交分享功能</p><h3 id="博客搜索"><a href="#博客搜索" class="headerlink" title="博客搜索"></a>博客搜索</h3><p>(1) 在博客应用的根目录安装插件<a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-searchdb --save<br></code></pre></td></tr></table></figure><p>(2) 在“应用配置”中添加以下配置开启博客搜索功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">symbols_count_time:</span><br>  <span class="hljs-attr">symbols:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">time:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">total_symbols:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">total_time:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="部署静态博客网站到码云-Gitee-静态页面空间"><a href="#部署静态博客网站到码云-Gitee-静态页面空间" class="headerlink" title="部署静态博客网站到码云(Gitee)静态页面空间"></a>部署静态博客网站到码云(Gitee)静态页面空间</h2><ol><li><p>在码云上创建一个与你账号同名的Git代码仓库，比如”ruokiy”;</p><blockquote><p>在创建时选择用README初始化仓库，这样创建出来的代码仓库缺省会带有master分支</p></blockquote></li><li><p>安装插件hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>在“应用配置”中添加一下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>   <span class="hljs-attr">repo:</span> <span class="hljs-string">https://gitee.com/ruokiy/ruokiy.git</span><br>   <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，最终deploy过程是将产生的静态博客网站文件提交到新创建的Git代码仓库的master分支上，所以做deploy的机子上需要能够写访问Git代码仓库。这里是通过https协议访问Git代码仓库的，所以你需要在deploy的机子上，也就是装有Git客户端的机子上设置以下的Git配置：<br>git config –global credential.helper store<br>尝试手动克隆一次代码仓库，根据提示输入用户名和密码，这样你的用户名和密码就会被缓存到机子上了。之后的访问都不要用户名和密码了。</p></blockquote></li><li><p>在博客应用的根目录执行以下命令完成静态博客文件的上传</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure></li><li><p>如下图，在码云上点击刚创建的代码仓库页面，点击菜单“Service|Gitee Pages”，在左侧选择“master”分支，点击“create”按钮<br> <img src="/2018/08/17/setup-blog-hexo-gitee/2.png"></p></li></ol><p>不到一分钟，你的静态博客网站就生成了。可以拷贝生成的网址输入到浏览器打开你的博客了，同时你也可以把这个网址分享给你的朋友，或者放在你的个人简介中。</p><h1 id="最后一公里-将博客应用的代码托管到码云"><a href="#最后一公里-将博客应用的代码托管到码云" class="headerlink" title="最后一公里 - 将博客应用的代码托管到码云"></a>最后一公里 - 将博客应用的代码托管到码云</h1><p>这里会用到Git submodule的概念。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
